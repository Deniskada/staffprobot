# План установки и настройки Supercode.sh для StaffProBot

## Этап 1: Установка Supercode.sh

### Шаг 1.1: Скачать расширение
```bash
# Вариант 1: Через браузер
# Открыть https://supercode.sh/releases/supercode-2.1.4.vsix и сохранить файл

# Вариант 2: Через curl (если соединение стабильное)
cd /tmp
curl -L -o supercode-2.1.4.vsix https://supercode.sh/releases/supercode-2.1.4.vsix
```

### Шаг 1.2: Установить в Cursor
1. Открыть Cursor
2. Нажать `Ctrl+Shift+X` (или `Cmd+Shift+X` на Mac) для открытия панели Extensions
3. Перетащить файл `supercode-2.1.4.vsix` в панель Extensions
4. Дождаться завершения установки (до 2 минут на Linux)
5. Авторизоваться при появлении запроса

### Шаг 1.3: Проверка установки
- В Cursor должна появиться команда `Supercode: Open Settings`
- В Command Palette (`Ctrl+Shift+P`) должны быть команды Supercode

## Этап 2: Настройка режимов (Custom Modes)

### Режим 1: "StaffPro Architect"
**Назначение**: Архитектурный контроль и соблюдение правил проекта

**Настройка через Supercode UI:**
1. Открыть `Supercode: Create Custom Mode`
2. Название: `StaffPro Architect`
3. Описание: `Архитектурный контроль для StaffProBot: проверка правил user_id, роутов, Docker, DDD`

**Системный промпт (вставить в настройки режима):**
```
Ты архитектурный контролёр для проекта StaffProBot.

КРИТИЧЕСКИЕ ПРАВИЛА:
1. user_id - это внутренний ID из БД, НЕ telegram_id!
   - ВСЕГДА использовать: get_user_id_from_current_user(current_user, session)
   - НИКОГДА не использовать: current_user.get("id") как user_id

2. Роутинг:
   - /owner/* только в routes/owner/
   - /manager/* только в routes/manager/
   - НЕ дублировать роуты с одинаковым методом и путём

3. Шаблоны:
   - ТОЛЬКО: from apps.web.jinja import templates
   - НЕ создавать локальные Jinja2Templates

4. Сессии БД:
   - ТОЛЬКО: Depends(get_db_session)
   - НЕ использовать: async with get_async_session()

5. URLHelper:
   - ВСЕГДА: URLHelper.get_web_url("/path")
   - НЕ хардкодить домены

6. Docker:
   - apps/web/* → restart web
   - apps/bot/* → restart bot
   - shared/domain/* → restart web bot celery_worker celery_beat

ПЕРЕД ЛЮБЫМ ИЗМЕНЕНИЕМ:
- Проверить через grep/codebase_search существующий код
- При сомнениях - спросить Project Brain: http://192.168.2.107:8003/chat

ПОСЛЕ ИЗМЕНЕНИЙ:
- Проверить read_lints
- Предложить команду перезапуска контейнеров
- Напомнить об обновлении roadmap.md
```

### Режим 2: "Roadmap Executor"
**Назначение**: Строгое следование roadmap и workflow

**Системный промпт:**
```
Ты исполнитель задач из roadmap.md для StaffProBot.

ОБЯЗАТЕЛЬНЫЙ ПОРЯДОК:
1. Прочитать doc/plans/roadmap.md и найти текущую задачу
2. НЕ ПЕРЕПРЫГИВАТЬ задачи - выполнять строго по порядку
3. ПЕРЕД реализацией - предложить решение и дождаться подтверждения
4. ПОСЛЕ реализации - показать результат и дождаться подтверждения
5. Обновить roadmap.md: отметить задачу как выполненную, обновить прогресс

WORKFLOW ДЛЯ КАЖДОЙ ЗАДАЧИ:
1. Прочитать задачу из roadmap.md
2. Проанализировать зависимости
3. Предложить решение с примерами кода
4. Дождаться подтверждения
5. Реализовать
6. Показать результат
7. Дождаться подтверждения
8. Обновить roadmap.md
9. Создать коммит на русском: "Тип: Краткое описание"

ФОРМАТ ОБНОВЛЕНИЯ ROADMAP:
- В шапке: обновить "Общий прогресс: X/Y (Z%)"
- В итерации: отметить [x] задачу
- Добавить Type, Files, Acceptance критерии
```

### Режим 3: "Refactor & Review"
**Назначение**: Безопасный рефакторинг и ревью

**Системный промпт:**
```
Ты рефакторинг-эксперт для StaffProBot.

ПРИНЦИПЫ:
- KISS: простота > элегантность
- SOLID: Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion
- DRY: не дублировать код
- Типизация: 100% type hints

ПЕРЕД РЕФАКТОРИНГОМ:
1. Прочитать существующий код полностью
2. Найти все использования изменяемого кода (grep)
3. Предложить план рефакторинга
4. Дождаться подтверждения

ПОСЛЕ РЕФАКТОРИНГА:
1. Проверить read_lints
2. Запустить тесты: docker compose -f docker-compose.dev.yml exec web pytest tests/
3. Убедиться, что функциональность не сломана
4. Обновить документацию при необходимости

ПРОВЕРКИ:
- Нет дублирования кода
- Все функции имеют type hints
- Обработка ошибок через try/except с логированием
- Использование структурированного логирования (logger.info/error)
```

## Этап 3: Создание Workflows

### Workflow 1: "Новая задача из roadmap"
**Триггер**: Ручной запуск через Supercode UI

**Шаги:**
1. AI Query: "Прочитай doc/plans/roadmap.md и найди первую невыполненную задачу. Покажи её описание, зависимости и файлы."
2. AI Query: "Предложи план реализации этой задачи с примерами кода и архитектурными решениями."
3. User Input: Ожидание подтверждения от пользователя
4. AI Query: "Реализуй задачу согласно подтверждённому плану."
5. AI Query: "Проверь код через read_lints и предложи команды для тестирования."
6. AI Query: "Обнови doc/plans/roadmap.md: отметь задачу как выполненную, обновь прогресс."
7. AI Query: "Предложи короткое сообщение для коммита на русском языке."

### Workflow 2: "Правки в apps/web/routes"
**Триггер**: При изменении файлов в `apps/web/routes/**/*.py`

**Шаги:**
1. AI Query: "Проверь изменённые файлы на соблюдение правил:
   - Префиксы ролей (/owner, /manager, /employee)
   - Отсутствие дублирующих роутов
   - Использование templates из apps.web.jinja
   - Использование Depends(get_db_session)
   - Использование URLHelper вместо хардкода URL"
2. AI Query: "Если найдены нарушения - предложи исправления."
3. JavaScript: `readLints()` - проверка линтера
4. AI Query: "Предложи команду pytest для тестирования изменённых роутов."

### Workflow 3: "Правки в shared/domain"
**Триггер**: При изменении файлов в `shared/**/*.py` или `domain/**/*.py`

**Шаги:**
1. AI Query: "Определи, какие контейнеры нужно перезапустить (web, bot, celery_worker, celery_beat)."
2. JavaScript: Предложить команду перезапуска
3. AI Query: "Предложи интеграционные тесты для проверки изменений."

### Workflow 4: "Подготовка коммита"
**Триггер**: Ручной запуск перед коммитом

**Шаги:**
1. JavaScript: `git status` - показать изменённые файлы
2. AI Query: "Проанализируй изменения и предложи короткое сообщение коммита на русском в формате 'Тип: Краткое описание'."
3. User Input: Подтверждение сообщения
4. JavaScript: Выполнить `git add` и `git commit` с предложенным сообщением

## Этап 4: Интеграция с Project Brain

### Workflow 5: "Вопрос к Project Brain"
**Триггер**: Ручной запуск

**Шаги:**
1. User Input: Вопрос о коде/архитектуре
2. JavaScript: Отправить POST запрос к `http://192.168.2.107:8003/api/query`
3. AI Query: "Обработай ответ Project Brain и покажи файлы, строки и правила."

## Этап 5: Документация и чеклист

### Обновление CHECKLIST.md
Добавить раздел проверки Supercode:
- Проверка установки расширения
- Проверка работы режимов
- Проверка workflows

### Создание документации использования
Создать файл `.cursor/SUPERCODE_USAGE.md` с примерами использования режимов и workflows.

## Этап 6: Ежедневное использование

### Утренний ритуал:
1. Выбрать режим "Roadmap Executor"
2. Запустить workflow "Новая задача из roadmap"
3. Работать в выбранном режиме весь день

### Перед коммитом:
1. Переключиться на режим "Refactor & Review"
2. Запустить workflow "Подготовка коммита"

### При архитектурных вопросах:
1. Переключиться на режим "StaffPro Architect"
2. Запустить workflow "Вопрос к Project Brain"

## Следующие шаги

1. ✅ Установить Supercode.sh
2. ✅ Настроить режимы (StaffPro Architect, Roadmap Executor, Refactor & Review)
3. ✅ Создать workflows
4. ✅ Протестировать режимы на реальных задачах
5. ✅ Настроить автоматические триггеры workflows
6. ✅ Документировать опыт использования

---

**Дата создания**: 2026-02-04  
**Статус**: План готов к реализации
