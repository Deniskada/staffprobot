---
alwaysApply: true
---

# StaffProBot — единые правила Cursor (актуально)

## 1) Базовые принципы

- **Краткость**: отвечай и действуй по делу, без повторов.
- **KISS/DRY**: простые решения, без дублирования логики.
- **Не выдумывать**: перед изменениями находи существующий код через поиск, затем читай файл.
- **Docker-first**: проект разрабатывается и проверяется через Docker Compose.

## 2) Процесс работы (обязательно)

Перед реализацией:
- Сформулировать план (что/где меняем, риски, тест-план).
- Дождаться подтверждения пользователя.

После реализации:
- Показать результат.
- Дождаться подтверждения.

## 3) Docker (dev)

- **Запуск**: `docker compose -f docker-compose.dev.yml up -d`
- **Остановка**: `docker compose -f docker-compose.dev.yml down`
- **Команды в web**: `docker compose -f docker-compose.dev.yml exec web ...`

Перезапуски:
- Изменения в `apps/web/*` → `restart web`
- Изменения в `apps/bot/*` → `restart bot`
- Изменения в `shared/*` или `domain/*` → `restart web bot celery_worker celery_beat`

## 4) Критические правила кода (нельзя нарушать)

### 4.1. `user_id` vs `telegram_id`

`user_id` — внутренний ID из БД, **не** `telegram_id`.

```python
# ❌ Неправильно (telegram_id)
user_id = current_user.get("id")

# ✅ Правильно (внутренний user_id)
from shared.services.user_service import get_user_id_from_current_user
user_id = await get_user_id_from_current_user(current_user, session)
```

### 4.2. Роутинг по ролям

- Префиксы ролей задаются **только** в `apps/web/app.py` через `include_router(...)`.
- В файлах роутов **не** дублировать `/owner`, `/manager`, `/employee`.
- Не допускать дублей: один метод + один путь = один обработчик.

### 4.3. Jinja templates

```python
# ✅ Только так
from apps.web.jinja import templates
```

Запрещено создавать локальные `Jinja2Templates(...)`.

### 4.4. Сессии БД в web-роутах

- Только `Depends(get_db_session)`.
- Запрещено: `async with get_async_session()` в web-роутах.

### 4.5. URLHelper

Запрещён хардкод доменов/URL:

```python
from core.utils.url_helper import URLHelper
URLHelper.get_web_url("/owner/objects")
```

### 4.6. Статика

В шаблонах для CSS/JS использовать `| static_version`.

### 4.7. Telegram-уведомления: ссылки с авто-логином

Каждое Telegram-сообщение, связанное с действием, **обязано** содержать смысловую ссылку на соответствующий раздел ЛК.

Правила:
1. В шаблоне `base_templates.py` добавлять `$link_url` в конец telegram-варианта.
2. `NotificationDispatcher._inject_auto_login_url()` автоматически подставляет URL с одноразовым auto-login токеном.
3. Маппинг тип → путь определяется в `NotificationActionService.get_action_url()`.
4. Прямые отправки через `bot.send_message()` должны использовать `build_auto_login_url()`:

```python
from core.auth.auto_login import build_auto_login_url
url = await build_auto_login_url(telegram_id, "/employee/offers/123", base_url)
```

5. При добавлении нового типа уведомления:
   - Добавить маппинг в `NotificationActionService.get_action_url()`
   - Добавить `$link_url` в Telegram-шаблон
   - Передавать `object_id`/`contract_id`/`shift_id` в `data` при `create_notification()`

## 5) Документация и планирование (активный контур)

- **Roadmap**: `doc/plans/roadmap.md` (формат фазы/версии/эпики).
- **Цели**: `doc/plans/goals_map.md` и `doc/plans/goals_optimization.md`.
- Старые документы держим в `local_archive/` (не в git).

## 6) Инструменты (использовать по умолчанию)

### 6.1. Cursor Memory Bank

Использовать команды:
- `/van` → инициализация и сбор контекста
- `/plan` → план работ
- `/build` → реализация
- `/reflect` → итог/проверки
- `/archive` → фиксация результата

### 6.2. Supercode.sh

Использовать режимы:
- **Roadmap Executor** — последовательное выполнение задач
- **StaffPro Architect** — контроль критических правил
- **Refactor & Review** — проверка качества перед коммитом

### 6.3. OpenSpec + Spec Kit

Спеки как "источник истины" для крупных изменений:
- `openspec/specs/*` — актуальные спецификации (OpenSpec)
- `openspec/changes/*` — активные предложения изменений (OpenSpec)
- `specs/capabilities/*` — актуальные спецификации (Spec Kit, legacy)
- `changes/active/*` — активные предложения изменений (legacy)

**Рекомендуется использовать OpenSpec** (`openspec/`) для новых спецификаций.

CLI (Spec Kit):
- `specify init` / `specify check` / `specify version`

**Документация**: `.cursor/docs/OPENSPEC_USAGE.md` и `.cursor/docs/MEMORY_BANK_USAGE.md`

### 6.4. TaskMaster (если включён)

Использовать для декомпозиции больших задач и трекинга подзадач.

## 7) Коммиты

- Сообщения **на русском**, максимально короткие.
- Формат: `Тип: Кратко` (например, `Обновление: правила Cursor`).

