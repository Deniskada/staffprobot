---
alwaysApply: true
---

# Правила разработки кода StaffProBot

## Общие принципы

### KISS (Keep It Simple, Stupid)
- Пиши простой, понятный код
- Избегай излишней сложности и "умных" решений
- Приоритет читаемости над "элегантностью"

### SOLID принципы
- **S** - Single Responsibility: один класс = одна ответственность
- **O** - Open/Closed: открыт для расширения, закрыт для изменения
- **L** - Liskov Substitution: наследники должны заменять базовые классы
- **I** - Interface Segregation: много маленьких интерфейсов лучше одного большого
- **D** - Dependency Inversion: зависимости от абстракций, а не от конкретных классов

### DRY (Don't Repeat Yourself)
- Не дублируй код
- Выноси повторяющуюся логику в функции/классы
- Используй наследование и композицию

## Архитектурные правила

### Domain-Driven Design
- Разделяй код по бизнес-доменам
- Используй слоистую архитектуру: domain → infrastructure → application
- Моделируй бизнес-сущности как объекты, а не структуры данных

### Микросервисная архитектура
- Каждый сервис должен быть независимым
- Используй асинхронную коммуникацию через события
- Минимизируй межсервисные зависимости

### CQRS
- Разделяй операции чтения и записи
- Оптимизируй модели для конкретных сценариев использования
- Используй отдельные схемы для команд и запросов

## Качество кода

### Типизация
- **Обязательно** используй type hints для всех функций и методов
- Используй `Optional[T]` для nullable значений
- Определяй кастомные типы для сложных структур

```python
# ✅ Правильно
def create_user(name: str, email: str, role: UserRole) -> User:
    pass

# ❌ Неправильно
def create_user(name, email, role):
    pass
```

### Обработка ошибок
- Используй кастомные исключения для бизнес-логики
- Логируй все ошибки с контекстом
- Не проглатывай исключения без логирования

```python
# ✅ Правильно
try:
    user = await user_service.create_user(data)
except ValidationError as e:
    logger.error("User validation failed", user_data=data, error=str(e))
    raise
except DatabaseError as e:
    logger.error("Database error during user creation", error=str(e))
    raise UserCreationError("Failed to create user")
```

### Логирование
- Используй структурированное логирование (JSON)
- Логируй важные бизнес-события
- Добавляй контекст: user_id, request_id, execution_time

```python
logger.info(
    "Shift opened successfully",
    user_id=user_id,
    shift_id=shift_id,
    object_id=object_id,
    coordinates=coordinates
)
```

## Тестирование

### Покрытие кода
- **Цель: 90%+ покрытие тестами**
- Пиши unit-тесты для бизнес-логики
- Используй integration-тесты для API
- Мокай внешние зависимости

### Структура тестов
```
tests/
├── unit/           # Модульные тесты
├── integration/    # Интеграционные тесты
└── fixtures/       # Общие тестовые данные
```

### Именование тестов
```python
def test_create_user_with_valid_data_should_succeed():
    pass

def test_create_user_with_invalid_email_should_fail():
    pass
```

## Работа с LLM

### Промпт-инженерия
- Используй четкие, структурированные промпты
- Разделяй системные и пользовательские промпты
- Валидируй ответы LLM перед использованием

### Обработка ошибок LLM
- Всегда имей fallback-механизм
- Логируй все запросы к LLM
- Мониторь качество ответов

### Контекст диалога
- Ограничивай размер контекста (max 10 сообщений)
- Создавай краткие резюме для длинных диалогов
- Очищай устаревший контекст

## База данных

### SQLAlchemy 2.0
- Используй async/await синтаксис
- Применяй миграции через Alembic
- Используй connection pooling

### Оптимизация запросов
- Создавай индексы для часто используемых полей
- Избегай N+1 проблем
- Используй bulk операции для массовых данных

### Геоданные
- Используй PostGIS для геопространственных запросов
- Создавай GIST индексы для координат
- Валидируй координаты перед сохранением

## Безопасность

### Валидация данных
- Используй Pydantic для валидации входных данных
- Проверяй права доступа на уровне API
- Санитизируйте пользовательский ввод

### Аутентификация
- Используй JWT токены с коротким временем жизни
- Храни секреты в переменных окружения
- Логируй все попытки аутентификации

## Производительность

### Асинхронность
- Используй async/await для I/O операций
- Применяй connection pooling для БД
- Используй Redis для кэширования

### Мониторинг
- Добавляй метрики Prometheus
- Логируй время выполнения операций
- Настрой алерты для критических метрик

## Стиль кода

### Форматирование
- Используй Black для автоматического форматирования
- Следуй PEP 8
- Максимальная длина строки: 88 символов

### Именование
- Используй snake_case для функций и переменных
- PascalCase для классов
- UPPER_CASE для констант

### Документация
- Пиши docstrings для всех публичных функций
- Используй type hints как документацию
- Обновляй README при изменении API

## CI/CD

### Pre-commit hooks
- Автоматическое форматирование кода
- Проверка типов через MyPy
- Линтинг через Flake8

### Автоматические тесты
- Запуск тестов на каждый PR
- Проверка покрытия кода
- Автоматический деплой после успешных тестов

## Ссылки

- [Техническое видение проекта](vision.md) - подробное описание архитектуры и технологий
- [Структура проекта](vision.md#23-структура-проекта) - организация файлов и папок
- [Модель данных](vision.md#24-модель-данных) - схемы таблиц и индексы
- [Работа с LLM](vision.md#25-работа-с-llm) - интеграция с языковыми моделями

---

**Важно**: Эти правила основаны на принципах из `vision.md` и должны соблюдаться при разработке. При возникновении вопросов обращайся к основному документу видения проекта.

## Дополнительные правила

- [Правила миграций и системных проблем](migrations.mdc) - работа с БД, Docker, отладка
- [Правила выполнения работ](workflow.mdc) - процесс разработки и согласования
# Правила разработки кода StaffProBot

## Общие принципы

### KISS (Keep It Simple, Stupid)
- Пиши простой, понятный код
- Избегай излишней сложности и "умных" решений
- Приоритет читаемости над "элегантностью"

### SOLID принципы
- **S** - Single Responsibility: один класс = одна ответственность
- **O** - Open/Closed: открыт для расширения, закрыт для изменения
- **L** - Liskov Substitution: наследники должны заменять базовые классы
- **I** - Interface Segregation: много маленьких интерфейсов лучше одного большого
- **D** - Dependency Inversion: зависимости от абстракций, а не от конкретных классов

### DRY (Don't Repeat Yourself)
- Не дублируй код
- Выноси повторяющуюся логику в функции/классы
- Используй наследование и композицию

## Архитектурные правила

### Domain-Driven Design
- Разделяй код по бизнес-доменам
- Используй слоистую архитектуру: domain → infrastructure → application
- Моделируй бизнес-сущности как объекты, а не структуры данных

### Микросервисная архитектура
- Каждый сервис должен быть независимым
- Используй асинхронную коммуникацию через события
- Минимизируй межсервисные зависимости

### CQRS
- Разделяй операции чтения и записи
- Оптимизируй модели для конкретных сценариев использования
- Используй отдельные схемы для команд и запросов

## Качество кода

### Типизация
- **Обязательно** используй type hints для всех функций и методов
- Используй `Optional[T]` для nullable значений
- Определяй кастомные типы для сложных структур

```python
# ✅ Правильно
def create_user(name: str, email: str, role: UserRole) -> User:
    pass

# ❌ Неправильно
def create_user(name, email, role):
    pass
```

### Обработка ошибок
- Используй кастомные исключения для бизнес-логики
- Логируй все ошибки с контекстом
- Не проглатывай исключения без логирования

```python
# ✅ Правильно
try:
    user = await user_service.create_user(data)
except ValidationError as e:
    logger.error("User validation failed", user_data=data, error=str(e))
    raise
except DatabaseError as e:
    logger.error("Database error during user creation", error=str(e))
    raise UserCreationError("Failed to create user")
```

### Логирование
- Используй структурированное логирование (JSON)
- Логируй важные бизнес-события
- Добавляй контекст: user_id, request_id, execution_time

```python
logger.info(
    "Shift opened successfully",
    user_id=user_id,
    shift_id=shift_id,
    object_id=object_id,
    coordinates=coordinates
)
```

## Тестирование

### Покрытие кода
- **Цель: 90%+ покрытие тестами**
- Пиши unit-тесты для бизнес-логики
- Используй integration-тесты для API
- Мокай внешние зависимости

### Структура тестов
```
tests/
├── unit/           # Модульные тесты
├── integration/    # Интеграционные тесты
└── fixtures/       # Общие тестовые данные
```

### Именование тестов
```python
def test_create_user_with_valid_data_should_succeed():
    pass

def test_create_user_with_invalid_email_should_fail():
    pass
```

## Работа с LLM

### Промпт-инженерия
- Используй четкие, структурированные промпты
- Разделяй системные и пользовательские промпты
- Валидируй ответы LLM перед использованием

### Обработка ошибок LLM
- Всегда имей fallback-механизм
- Логируй все запросы к LLM
- Мониторь качество ответов

### Контекст диалога
- Ограничивай размер контекста (max 10 сообщений)
- Создавай краткие резюме для длинных диалогов
- Очищай устаревший контекст

## База данных

### SQLAlchemy 2.0
- Используй async/await синтаксис
- Применяй миграции через Alembic
- Используй connection pooling

### Оптимизация запросов
- Создавай индексы для часто используемых полей
- Избегай N+1 проблем
- Используй bulk операции для массовых данных

### Геоданные
- Используй PostGIS для геопространственных запросов
- Создавай GIST индексы для координат
- Валидируй координаты перед сохранением

## Безопасность

### Валидация данных
- Используй Pydantic для валидации входных данных
- Проверяй права доступа на уровне API
- Санитизируйте пользовательский ввод

### Аутентификация
- Используй JWT токены с коротким временем жизни
- Храни секреты в переменных окружения
- Логируй все попытки аутентификации

## Производительность

### Асинхронность
- Используй async/await для I/O операций
- Применяй connection pooling для БД
- Используй Redis для кэширования

### Мониторинг
- Добавляй метрики Prometheus
- Логируй время выполнения операций
- Настрой алерты для критических метрик

## Стиль кода

### Форматирование
- Используй Black для автоматического форматирования
- Следуй PEP 8
- Максимальная длина строки: 88 символов

### Именование
- Используй snake_case для функций и переменных
- PascalCase для классов
- UPPER_CASE для констант

### Документация
- Пиши docstrings для всех публичных функций
- Используй type hints как документацию
- Обновляй README при изменении API

## CI/CD

### Pre-commit hooks
- Автоматическое форматирование кода
- Проверка типов через MyPy
- Линтинг через Flake8

### Автоматические тесты
- Запуск тестов на каждый PR
- Проверка покрытия кода
- Автоматический деплой после успешных тестов

## Ссылки

- [Техническое видение проекта](vision.md) - подробное описание архитектуры и технологий
- [Структура проекта](vision.md#23-структура-проекта) - организация файлов и папок
- [Модель данных](vision.md#24-модель-данных) - схемы таблиц и индексы
- [Работа с LLM](vision.md#25-работа-с-llm) - интеграция с языковыми моделями

---

**Важно**: Эти правила основаны на принципах из `vision.md` и должны соблюдаться при разработке. При возникновении вопросов обращайся к основному документу видения проекта.

## Дополнительные правила

- [Правила миграций и системных проблем](migrations.mdc) - работа с БД, Docker, отладка
- [Правила выполнения работ](workflow.mdc) - процесс разработки и согласования
