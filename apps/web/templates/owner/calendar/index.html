{% extends "owner/base_owner.html" %}

{% block title %}{{ title }}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', path='css/shared/calendar.css') }}">
<style>
/* Owner-specific calendar styles */

/* Drag & Drop Panels */
.drag-drop-panel {
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 280px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 999;
    transition: all 0.3s ease;
}

.drag-drop-panel.collapsed {
    width: 60px;
    height: 60px;
}

.drag-drop-panel.collapsed .panel-content {
    display: none;
}

.drag-drop-panel.collapsed .panel-header h6 {
    display: none;
}

.drag-drop-panel.collapsed .panel-header {
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 5px;
    height: 60px;
    width: 60px;
    border-radius: 50%;
    background: #007bff;
}

.drag-drop-panel.collapsed .panel-header button {
    display: none;
}

.drag-drop-panel.collapsed .collapsed-icon {
    display: flex !important;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.2rem;
}

.drag-drop-panel.collapsed .objects-count {
    position: absolute;
    top: -5px;
    right: -5px;
}

.drag-drop-panel.collapsed .objects-count .badge {
    font-size: 0.7rem;
    padding: 0.25rem 0.4rem;
}

.employees-panel {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 280px;
    max-height: 400px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 999;
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
}

.employees-panel.collapsed {
    width: 60px;
    height: 60px;
}

.employees-panel.collapsed .panel-content {
    display: none;
}

.employees-panel.collapsed .panel-header h6 {
    display: none;
}

.employees-panel.collapsed .panel-header {
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 5px;
    height: 60px;
    width: 60px;
    border-radius: 50%;
    background: #28a745;
}

.employees-panel.collapsed .panel-header button {
    display: none;
}

.employees-panel.collapsed .collapsed-icon {
    display: flex !important;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.2rem;
}

.employees-panel.collapsed .employees-count {
    position: absolute;
    top: -5px;
    right: -5px;
}

.employees-panel.collapsed .employees-count .badge {
    font-size: 0.7rem;
    padding: 0.25rem 0.4rem;
}

.panel-header {
    padding: 15px;
    border-bottom: 1px solid #dee2e6;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #f8f9fa;
    border-radius: 10px 10px 0 0;
}

.panel-content {
    padding: 15px;
    max-height: 250px;
    overflow-y: auto;
    flex: 1;
    min-height: 0;
}

.panel-actions {
    border-top: 1px solid #dee2e6;
    padding-top: 15px;
}

.object-item, .employee-item {
    padding: 10px;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    margin-bottom: 8px;
    cursor: grab;
    transition: all 0.2s ease;
    background: white;
}

.object-item:hover, .employee-item:hover {
    background: #f8f9fa;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.object-item:active, .employee-item:active {
    cursor: grabbing;
    transform: scale(0.98);
}

.object-name, .employee-name {
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 4px;
}

.object-address, .employee-role {
    font-size: 0.8rem;
    color: #6c757d;
}

/* Responsive */
@media (max-width: 768px) {
    .drag-drop-panel, .employees-panel {
        position: relative;
        left: auto;
        right: auto;
        top: auto;
        transform: none;
        width: 100%;
        margin-bottom: 20px;
    }
    
    .drag-drop-panel.collapsed, .employees-panel.collapsed {
        width: 100%;
        height: auto;
    }
    
    .drag-drop-panel.collapsed .panel-header, .employees-panel.collapsed .panel-header {
        flex-direction: row;
        justify-content: space-between;
    padding: 15px;
        height: auto;
        width: 100%;
        border-radius: 10px 10px 0 0;
        background: #f8f9fa;
    }
    
    .drag-drop-panel.collapsed .panel-header h6, .employees-panel.collapsed .panel-header h6 {
        display: block;
    }
    
    .drag-drop-panel.collapsed .panel-header button, .employees-panel.collapsed .panel-header button {
        display: block;
    }
    
    .drag-drop-panel.collapsed .collapsed-icon, .employees-panel.collapsed .collapsed-icon {
        display: none !important;
    }
}
</style>
{% endblock %}

{% block content %}

<!-- Shared panels -->
{% include 'shared/calendar/objects_panel.html' %}
{% include 'shared/calendar/employees_panel.html' %}
{% include 'shared/calendar/quick_create_form.html' %}

<!-- Shared Calendar Grid -->
{% include 'shared/calendar/grid_unified.html' %}

{% endblock %}

{% block extra_js %}
<!-- Отключен старый calendar.js для тестирования -->
<!-- <script src="{{ url_for('static', path='js/shared/calendar.js') }}"></script> -->
<script src="{{ url_for('static', path='js/shared/calendar_panels.js') }}?v=20251004"></script>

<!-- Universal Calendar Integration -->
<script src="{{ url_for('static', path='js/shared/universal_calendar.js') }}?v=20251004"></script>
<script>
    // Инициализация универсального календаря для владельца
    document.addEventListener('DOMContentLoaded', function() {
        // Инициализируем панели drag&drop
        if (typeof CalendarPanels !== 'undefined') {
            window.calendarPanels = new CalendarPanels('owner');
            window.calendarPanels.init();
        }
        
        // Создаем экземпляр универсального календаря
        if (typeof UniversalCalendarManager !== 'undefined') {
            window.universalCalendar = new UniversalCalendarManager({
                currentDate: new Date({{ year }}, {{ month - 1 }}, 1),
                viewType: 'month',
                baseUrl: '/owner/calendar',
                userRole: 'owner',
                apiEndpoint: '/owner/calendar/api/data',
                onShiftClick: function(shiftId) {
                    console.log('Shift clicked:', shiftId);
                    if (shiftId.toString().startsWith('schedule_')) {
                        const scheduleId = shiftId.toString().replace('schedule_', '');
                        window.location.href = `/owner/shifts/${scheduleId}?shift_type=schedule`;
                    } else {
                        window.location.href = `/owner/shifts/${shiftId}?shift_type=shift`;
                    }
                },
                onTimeslotClick: function(timeslotId) {
                    console.log('Timeslot clicked:', timeslotId);
                    window.location.href = `/owner/timeslots/${timeslotId}`;
                },
                onDataLoaded: function(calendarData) {
                    console.log('Calendar data loaded:', calendarData);
                    // Используем унифицированную функцию отрисовки
                    if (window.renderCalendarGrid) {
                        window.renderCalendarGrid(calendarData);
                    }
                }
            });
        }
    });
</script>

<script>
// Экспорт данных календаря для JS-логики занятости
window.calendar_weeks = {{ calendar_weeks | tojson }};

// Define callback functions before using them
function showShiftDetails(shiftId) {
    if (shiftId.toString().startsWith('schedule_')) {
        const scheduleId = shiftId.toString().replace('schedule_', '');
        window.location.href = `/owner/shifts/${scheduleId}?shift_type=schedule`;
    } else {
        window.location.href = `/owner/shifts/${shiftId}?shift_type=shift`;
    }
}

function showTimeslotDetails(timeslotId) {
    window.location.href = `/owner/timeslots/${timeslotId}`;
}

function showDateDetails(date) {}

// Initialize calendar panels for owner role
const calendarPanels = new CalendarPanels('owner');

// Override universal calendar manager methods for drag&drop
if (window.universalCalendar) {
    window.universalCalendar.assignEmployeeToTimeslot = async function(employeeId, timeslotId) {
    try {
        console.log(`Planning shift: employeeId=${employeeId}, timeslotId=${timeslotId}`);
        const employeeResponse = await fetch(`/owner/api/employees`);
        if (!employeeResponse.ok) {
            throw new Error(`HTTP ${employeeResponse.status}: ${employeeResponse.statusText}`);
        }
        const employees = await employeeResponse.json();
        const employee = employees.find(emp => emp.id == parseInt(employeeId));
        if (!employee) {
            console.log(`Employee not found: ${employeeId}`);
            calendarPanels.showNotification('Сотрудник не найден', 'error');
            return;
        }
        console.log(`Found employee:`, employee);
        const timeslotResponse = await fetch(`/owner/calendar/api/timeslot/${timeslotId}`);
        if (!timeslotResponse.ok) {
            throw new Error(`HTTP ${timeslotResponse.status}: ${timeslotResponse.statusText}`);
        }
        const timeslot = await timeslotResponse.json();
        if (!timeslot) {
            console.log(`Timeslot not found: ${timeslotId}`);
            calendarPanels.showNotification('Тайм-слот не найден', 'error');
            return;
        }
        console.log(`Found timeslot:`, timeslot);
        const timeStr = timeslot.slot ? `${timeslot.slot.start_time} - ${timeslot.slot.end_time}` : 'время не определено';
        const requestData = { timeslot_id: Number(timeslotId), employee_id: Number(employeeId) };
        console.log(`Sending request:`, requestData);
        const planResp = await fetch('/owner/api/calendar/plan-shift', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });
        const planData = await planResp.json().catch(() => ({}));
        if (!planResp.ok || planData.success === false) {
            const detail = planData && (planData.detail || planData.message);
            throw new Error(detail || `Не удалось запланировать смену (HTTP ${planResp.status})`);
        }
        calendarPanels.showNotification(`Сотрудник ${employee.name} назначен на тайм-слот ${timeStr}`, 'success');
        setTimeout(() => {
            if (window.universalCalendar) {
                window.universalCalendar.refresh();
            }
        }, 300);
    } catch (error) {
        console.error('Error assigning employee:', error);
        calendarPanels.showNotification(`Ошибка назначения сотрудника: ${error.message}`, 'error');
    }
};
}

if (window.universalCalendar) {
    window.universalCalendar.createTimeslotFromObject = async function(objectId, date) {
        try {
            const objectResponse = await fetch(`/owner/calendar/api/objects`);
            const objects = await objectResponse.json();
            const object = objects.find(obj => obj.id == objectId);
            if (!object) {
                calendarPanels.showNotification('Объект не найден', 'error');
                return;
            }
            await calendarPanels.showQuickCreateForm({
                id: objectId,
                name: object.name,
                hourlyRate: object.hourly_rate || 0,
                openingTime: object.opening_time || '09:00',
                closingTime: object.closing_time || '18:00'
            }, date);
        } catch (error) {
            console.error('Error creating timeslot from object:', error);
            calendarPanels.showNotification('Ошибка создания тайм-слота', 'error');
        }
    };
}

// Initialize panels on page load
document.addEventListener('DOMContentLoaded', function() {
    calendarPanels.init();
    setTimeout(() => {
        // Initialize timeslot occupancy
        initializeTimeslotOccupancy();
    }, 1000);
});

// Initialize timeslot occupancy
function initializeTimeslotOccupancy() {
    // Собираем смены только из данных страницы, не из DOM
    const scheduledShifts = [];

    // Из window.calendarData (если есть)
    if (window.calendarData && Array.isArray(window.calendarData.scheduled_shifts)) {
        window.calendarData.scheduled_shifts.forEach(shift => {
            if (shift && shift.time_slot_id && shift.status && shift.status !== 'cancelled') {
                scheduledShifts.push({
                    id: shift.id,
                    time_slot_id: Number(shift.time_slot_id),
                    status: shift.status
                });
            }
        });
    }

    // Из window.calendar_weeks (если есть)
    if (window.calendar_weeks && Array.isArray(window.calendar_weeks)) {
        window.calendar_weeks.forEach(week => {
            week.forEach(day => {
                if (day && Array.isArray(day.shifts)) {
                    day.shifts.forEach(shift => {
                        if (shift && shift.time_slot_id && shift.status && shift.status !== 'cancelled') {
                            scheduledShifts.push({
                                id: shift.id,
                                time_slot_id: Number(shift.time_slot_id),
                                status: shift.status
                            });
                        }
                    });
                }
            });
        });
    }

    console.log('Found scheduledShifts:', scheduledShifts.length);
    console.log('window.calendar_weeks exists:', !!window.calendar_weeks);
    console.log('window.calendarData exists:', !!window.calendarData);
    if (window.calendar_weeks && window.calendar_weeks.length > 0) {
        console.log('First week shifts:', window.calendar_weeks[0].map(day => day.shifts ? day.shifts.length : 0));
    }

    // Если смен нет в данных — подтягиваем с сервера статусы тайм-слотов как fallback
    const applyOccupancy = (shifts) => {
        // ПРАВИЛЬНАЯ ЛОГИКА: Группируем тайм-слоты по объектам и считаем смены для каждого
        const timeslotElements = document.querySelectorAll('.timeslot-item[data-timeslot-id]');
        const timeslotsByObject = {};

        // Группируем тайм-слоты по объектам
        timeslotElements.forEach(timeslot => {
            const timeslotId = parseInt(timeslot.dataset.timeslotId);
            const objectId = parseInt(timeslot.dataset.objectId);
            const maxEmployees = parseInt(timeslot.dataset.maxEmployees) || 1;

            if (!timeslotsByObject[objectId]) {
                timeslotsByObject[objectId] = [];
            }

            timeslotsByObject[objectId].push({
                element: timeslot,
                id: timeslotId,
                maxEmployees: maxEmployees
            });
        });

        // Для каждого объекта обрабатываем его тайм-слоты
        Object.keys(timeslotsByObject).forEach(objectId => {
            const objectTimeslots = timeslotsByObject[objectId];

            objectTimeslots.forEach(timeslot => {
                const timeslotId = timeslot.id;
                const maxEmployees = timeslot.maxEmployees;

                // Считаем смены ПРИВЯЗАННЫЕ к этому конкретному тайм-слоту (кроме cancelled)
                const shiftsForThisTimeslot = shifts.filter(shift =>
                    Number(shift.time_slot_id) === Number(timeslotId) && shift.status !== 'cancelled'
                );

                const currentShifts = shiftsForThisTimeslot.length;

                // Отладка для тайм-слота 181 (17 сентября)
                if (timeslotId === 181) {
                    console.log(`DEBUG Timeslot 181:`, {
                        timeslotId,
                        maxEmployees,
                        currentShifts,
                        shiftsForThisTimeslot,
                        willHide: currentShifts >= maxEmployees
                    });
                }

                if (currentShifts >= maxEmployees) {
                    // Скрываем заполненные тайм-слоты
                    timeslot.element.style.display = 'none';
                } else {
                    // Показываем незаполненные тайм-слоты
                    timeslot.element.style.display = '';
                    const occupancyIndicator = timeslot.element.querySelector('.timeslot-occupancy');
                    if (occupancyIndicator) {
                        occupancyIndicator.querySelector('.occupancy-text').textContent = `${currentShifts}/${maxEmployees}`;
                        if (currentShifts === 0) {
                            occupancyIndicator.className = 'timeslot-occupancy available';
                        } else {
                            occupancyIndicator.className = 'timeslot-occupancy partial';
                        }
                    }
                }
            });
        });
    };

    // Всегда применяем логику к найденным сменам
    if (scheduledShifts.length > 0) {
        applyOccupancy(scheduledShifts);
    } else {
        // Если смен нет в данных — подтягиваем с сервера статусы тайм-слотов как fallback
        const year = {{ year }};
        const month = {{ month }};
        fetch(`/owner/calendar/api/timeslots-status?year=${year}&month=${month}`)
            .then(r => r.json())
            .then(data => {
                // Преобразуем в вид со сдвигами на слот
                const shifts = [];
                (data || []).forEach(item => {
                    // planned shifts
                    (item.scheduled_shifts || []).forEach(s => {
                        if (s.status !== 'cancelled') {
                            shifts.push({ time_slot_id: item.slot_id, status: s.status });
                        }
                    });
                    // actual shifts
                    (item.actual_shifts || []).forEach(s => {
                        if (s.status !== 'cancelled') {
                            shifts.push({ time_slot_id: item.slot_id, status: s.status });
                        }
                    });
                });
                applyOccupancy(shifts);
            })
            .catch(() => applyOccupancy([]));
    }
}

// Проверяем доступность функции фильтрации
console.log('Calendar loaded, filterByObject available:', typeof window.filterByObject === 'function');

// ===== ФУНКЦИОНАЛ ПЛАНИРОВАНИЯ СМЕН ДЛЯ ВЛАДЕЛЬЦА =====

// Глобальные переменные для планирования смен
let availableTimeslots = [];
let selectedTimeslots = new Set();
let currentMonth = new Date().getMonth();
let currentYear = new Date().getFullYear();

// Показать модальное окно планирования
function showPlanShiftModal() {
    const modal = new bootstrap.Modal(document.getElementById('planShiftModal'));
    modal.show();
    loadPlanShiftObjects();
}

// Загрузка объектов для планирования
async function loadPlanShiftObjects() {
    try {
        const response = await fetch('/owner/calendar/api/objects');
        const objects = await response.json();
        
        const select = document.getElementById('planObjectSelect');
        select.innerHTML = '<option value="">Выберите объект</option>';
        
        if (Array.isArray(objects)) {
            objects.forEach(obj => {
                const option = document.createElement('option');
                option.value = obj.id;
                option.textContent = obj.name;
                select.appendChild(option);
            });
        }
        
        // Обработчик изменения объекта
        select.addEventListener('change', function() {
            if (this.value) {
                loadEmployeesForObject(this.value);
                clearCalendar(); // Очищаем календарь при смене объекта
            } else {
                clearCalendar();
                clearEmployees();
            }
        });
        
    } catch (error) {
        console.error('Ошибка загрузки объектов:', error);
    }
}

// Загрузка сотрудников для конкретного объекта
async function loadEmployeesForObject(objectId) {
    try {
        const response = await fetch(`/owner/api/employees/for-object/${objectId}`);
        const employees = await response.json();
        
        const select = document.getElementById('planEmployeeSelect');
        select.innerHTML = '<option value="">Выберите сотрудника</option>';
        
        if (Array.isArray(employees)) {
            employees.forEach(emp => {
                const option = document.createElement('option');
                option.value = emp.id;
                option.textContent = emp.name;
                select.appendChild(option);
            });
        }
        
        // Обработчик изменения сотрудника
        select.addEventListener('change', function() {
            const objectId = document.getElementById('planObjectSelect').value;
            if (this.value && objectId) {
                loadTimeslotsForObject(objectId);
            } else {
                clearCalendar();
            }
        });
        
    } catch (error) {
        console.error('Ошибка загрузки сотрудников для объекта:', error);
    }
}

// Очистка списка сотрудников
function clearEmployees() {
    const select = document.getElementById('planEmployeeSelect');
    select.innerHTML = '<option value="">Выберите сотрудника</option>';
}

// Очистка календаря
function clearCalendar() {
    const calendarEl = document.getElementById('planShiftCalendar');
    calendarEl.innerHTML = '<div class="text-center text-muted p-4">Выберите объект и сотрудника для отображения календаря</div>';
    availableTimeslots = [];
    selectedTimeslots.clear();
    updateSelectedSlotsInfo();
}

// Загрузка тайм-слотов для объекта
async function loadTimeslotsForObject(objectId) {
    try {
        const today = new Date();
        const startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const endDate = new Date(today.getFullYear(), today.getMonth() + 2, 0);
        
        const response = await fetch(`/owner/calendar/api/data?start_date=${formatDateForAPI(startDate)}&end_date=${formatDateForAPI(endDate)}&object_ids=${objectId}`);
        const data = await response.json();
        
        availableTimeslots = data.timeslots || [];
        console.log('Loaded timeslots:', availableTimeslots);
        updateCalendar();
        
    } catch (error) {
        console.error('Ошибка загрузки тайм-слотов:', error);
    }
}

// Форматирование даты для API
function formatDateForAPI(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Обновление календаря
function updateCalendar() {
    const calendarEl = document.getElementById('planShiftCalendar');
    const monthNames = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                       'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
    
    document.getElementById('calendarMonthYear').textContent = `${monthNames[currentMonth]} ${currentYear}`;
    
    // Создаем календарь
    createPlanShiftCalendar();
}

// Создание календаря планирования
function createPlanShiftCalendar() {
    const calendarEl = document.getElementById('planShiftCalendar');
    const firstDay = new Date(currentYear, currentMonth, 1);
    const lastDay = new Date(currentYear, currentMonth + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startDay = firstDay.getDay();
    
    let html = '<div class="calendar-grid-plan">';
    html += '<div class="calendar-header-plan">';
    html += '<div class="day-header">Пн</div>';
    html += '<div class="day-header">Вт</div>';
    html += '<div class="day-header">Ср</div>';
    html += '<div class="day-header">Чт</div>';
    html += '<div class="day-header">Пт</div>';
    html += '<div class="day-header">Сб</div>';
    html += '<div class="day-header">Вс</div>';
    html += '</div>';
    
    html += '<div class="calendar-days-plan">';
    
    // Пустые ячейки для начала месяца
    for (let i = 0; i < startDay; i++) {
        html += '<div class="calendar-day disabled"></div>';
    }
    
    // Дни месяца
    for (let day = 1; day <= daysInMonth; day++) {
        const date = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const timeslotsForDate = availableTimeslots.filter(ts => {
            const tsDate = ts.date || ts.slot_date || ts.start_date;
            return tsDate === date && ts.available_slots > 0;
        });
        
        const totalFreeSlots = timeslotsForDate.reduce((sum, ts) => sum + (ts.available_slots || 0), 0);
        
        let dayClass = 'calendar-day';
        if (timeslotsForDate.length === 0) {
            dayClass += ' disabled';
        } else {
            dayClass += ' available-timeslot';
        }
        
        if (selectedTimeslots.has(date)) {
            dayClass += ' selected';
        }
        
        html += `<div class="${dayClass}" data-date="${date}" data-timeslots="${totalFreeSlots}">`;
        html += `<div class="day-number">${day}</div>`;
        if (timeslotsForDate.length > 0) {
            html += `<div class="free-slots">${totalFreeSlots} свободно</div>`;
        }
        html += '</div>';
    }
    
    html += '</div></div>';
    calendarEl.innerHTML = html;
    
    // Добавляем обработчики кликов
    calendarEl.addEventListener('click', handleTimeslotClick);
}

// Обработка клика по тайм-слоту
async function handleTimeslotClick(e) {
    const day = e.target.closest('.calendar-day');
    if (!day || day.classList.contains('disabled') || !day.classList.contains('available-timeslot')) {
        return;
    }
    
    const date = day.dataset.date;
    const timeslots = parseInt(day.dataset.timeslots);
    
    if (timeslots === 0) return;
    
    const employeeId = document.getElementById('planEmployeeSelect').value;
    if (!employeeId) {
        alert('Сначала выберите сотрудника');
        return;
    }
    
    // Проверяем доступность сотрудника
    const isAvailable = await checkEmployeeAvailability(employeeId, date);
    
    if (isAvailable) {
        // Переключаем выбор
        if (selectedTimeslots.has(date)) {
            selectedTimeslots.delete(date);
            day.classList.remove('selected');
        } else {
            selectedTimeslots.add(date);
            day.classList.add('selected');
        }
        updateSelectedSlotsInfo();
    }
}

// Проверка доступности сотрудника
async function checkEmployeeAvailability(employeeId, date) {
    try {
        // Находим тайм-слот для этой даты
        const timeslot = availableTimeslots.find(ts => {
            const tsDate = ts.date || ts.slot_date || ts.start_date;
            return tsDate === date;
        });
        
        if (!timeslot) {
            alert('Тайм-слот не найден');
            return false;
        }
        
        // Отправляем запрос на проверку доступности
        const response = await fetch('/owner/api/calendar/check-availability', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                timeslot_id: parseInt(timeslot.id),
                employee_id: parseInt(employeeId)
            })
        });
        
        const result = await response.json();
        
        if (result.available) {
            return true;
        } else {
            alert(result.message || 'Сотрудник недоступен в это время');
            return false;
        }
        
    } catch (error) {
        console.error('Ошибка проверки доступности:', error);
        alert('Ошибка проверки доступности сотрудника');
        return false;
    }
}

// Обновление информации о выбранных слотах
function updateSelectedSlotsInfo() {
    const count = selectedTimeslots.size;
    const infoEl = document.getElementById('selectedSlotsInfo');
    const countEl = document.getElementById('selectedSlotsCount');
    const confirmBtn = document.getElementById('confirmPlanShift');
    
    if (count > 0) {
        infoEl.style.display = 'block';
        countEl.textContent = count;
        confirmBtn.disabled = false;
    } else {
        infoEl.style.display = 'none';
        confirmBtn.disabled = true;
    }
}

// Подтверждение планирования смен
async function confirmPlanShift() {
    const objectId = document.getElementById('planObjectSelect').value;
    const employeeId = document.getElementById('planEmployeeSelect').value;
    
    if (!objectId || !employeeId || selectedTimeslots.size === 0) {
        alert('Выберите объект, сотрудника и тайм-слоты');
        return;
    }
    
    const confirmBtn = document.getElementById('confirmPlanShift');
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Планирование...';
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const date of selectedTimeslots) {
        try {
            const timeslot = availableTimeslots.find(ts => {
                const tsDate = ts.date || ts.slot_date || ts.start_date;
                return tsDate === date;
            });
            
            if (!timeslot) continue;
            
            const response = await fetch('/owner/api/calendar/plan-shift', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    timeslot_id: parseInt(timeslot.id),
                    employee_id: parseInt(employeeId)
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                successCount++;
            } else {
                errorCount++;
                console.error('Ошибка планирования:', result.message);
            }
            
        } catch (error) {
            errorCount++;
            console.error('Ошибка планирования смены:', error);
        }
    }
    
    // Восстанавливаем кнопку
    confirmBtn.disabled = false;
    confirmBtn.innerHTML = '<i class="bi bi-calendar-check"></i> Запланировать смены';
    
    // Показываем результат
    if (successCount > 0) {
        alert(`Успешно запланировано смен: ${successCount}${errorCount > 0 ? `, ошибок: ${errorCount}` : ''}`);
        // Закрываем модальное окно
        const modal = bootstrap.Modal.getInstance(document.getElementById('planShiftModal'));
        modal.hide();
        // Обновляем календарь
        if (window.universalCalendar) {
            window.universalCalendar.loadData();
        }
    } else {
        alert('Не удалось запланировать ни одной смены');
    }
}

// Обработчики навигации по месяцам
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('prevMonth')?.addEventListener('click', function() {
        currentMonth--;
        if (currentMonth < 0) {
            currentMonth = 11;
            currentYear--;
        }
        updateCalendar();
    });
    
    document.getElementById('nextMonth')?.addEventListener('click', function() {
        currentMonth++;
        if (currentMonth > 11) {
            currentMonth = 0;
            currentYear++;
        }
        updateCalendar();
    });
    
    document.getElementById('confirmPlanShift')?.addEventListener('click', confirmPlanShift);
});

// CSS для календаря планирования
const planShiftCSS = `
<style>
.calendar-container {
    max-height: 400px;
    overflow-y: auto;
}

.calendar-grid-plan {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 1px;
    background: #dee2e6;
    border-radius: 8px;
    overflow: hidden;
}

.calendar-header-plan {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    background: #f8f9fa;
    font-weight: bold;
    text-align: center;
}

.day-header {
    padding: 8px;
    background: #e9ecef;
    border-bottom: 1px solid #dee2e6;
}

.calendar-days-plan {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 1px;
}

.calendar-day {
    min-height: 60px;
    background: white;
    padding: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.calendar-day:hover:not(.disabled) {
    background: #f8f9fa;
    transform: scale(1.02);
}

.calendar-day.available-timeslot {
    background: #e8f5e8;
}

.calendar-day.selected {
    background: #28a745 !important;
    color: white;
}

.calendar-day.disabled {
    background: #f8f9fa;
    color: #6c757d;
    cursor: not-allowed;
}

.day-number {
    font-weight: bold;
    font-size: 14px;
}

.free-slots {
    font-size: 10px;
    color: #28a745;
    font-weight: bold;
}

.calendar-day.selected .free-slots {
    color: white;
}

@media (max-width: 768px) {
    .calendar-day {
        min-height: 50px;
        padding: 2px;
    }
    
    .day-number {
        font-size: 12px;
    }
    
    .free-slots {
        font-size: 9px;
    }
}
</style>
`;

// Добавляем CSS в head
document.head.insertAdjacentHTML('beforeend', planShiftCSS);
</script>

{% endblock %}
