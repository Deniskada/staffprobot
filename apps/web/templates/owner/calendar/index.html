{% extends "owner/base_owner.html" %}

{% block title %}{{ title }}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', path='css/shared/calendar.css') }}">
<style>
/* Фиксированная высота страницы календаря - без вертикального скролла */
html, body {
    height: 100%;
    overflow: hidden;
}

body {
    display: flex;
    flex-direction: column;
}

/* Скрываем footer на странице календаря */
footer {
    display: none !important;
}

.content-wrapper {
    height: calc(100vh - var(--topbar-height, 60px)) !important;
    min-height: unset !important;
    padding: 0 !important;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

/* Календарь занимает всю высоту */
.calendar-wrapper {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
}

.calendar-header-fixed {
    flex-shrink: 0;
}

.calendar-scrollable {
    flex: 1;
    overflow-y: auto !important;
    overflow-x: hidden;
    min-height: 0;
}

/* Owner-specific calendar styles */

/* Employees Panel - Owner Override */
#employeesPanel.employees-panel {
    position: fixed !important;
    right: 20px !important;
    bottom: 100px !important;
    top: auto !important;
    transform: none !important;
    width: 280px;
    max-height: 400px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 999;
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
}

.employees-panel.collapsed {
    width: 60px;
    height: 60px;
}

.employees-panel.collapsed .panel-content {
    display: none;
}

.employees-panel.collapsed .panel-header h6 {
    display: none;
}

.employees-panel.collapsed .panel-header {
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 5px;
    height: 60px;
    width: 60px;
    border-radius: 50%;
    background: #28a745;
}

.employees-panel.collapsed .panel-header button {
    display: none;
}

.employees-panel.collapsed .collapsed-icon {
    display: flex !important;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.2rem;
}

.employees-panel.collapsed .employees-count {
    position: absolute;
    top: -5px;
    right: -5px;
}

.employees-panel.collapsed .employees-count .badge {
    font-size: 0.7rem;
    padding: 0.25rem 0.4rem;
}

.panel-header {
    padding: 15px;
    border-bottom: 1px solid #dee2e6;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #f8f9fa;
    border-radius: 10px 10px 0 0;
}

.panel-content {
    padding: 15px;
    max-height: 250px;
    overflow-y: auto;
    flex: 1;
    min-height: 0;
}

.panel-actions {
    border-top: 1px solid #dee2e6;
    padding-top: 15px;
}

.object-item, .employee-item {
    padding: 10px;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    margin-bottom: 8px;
    cursor: grab;
    transition: all 0.2s ease;
    background: white;
}

.object-item:hover, .employee-item:hover {
    background: #f8f9fa;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.object-item:active, .employee-item:active {
    cursor: grabbing;
    transform: scale(0.98);
}

.object-name, .employee-name {
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 4px;
}

.object-address, .employee-role {
    font-size: 0.8rem;
    color: #6c757d;
}

/* Responsive */
@media (max-width: 768px) {
    .drag-drop-panel, .employees-panel {
        position: relative;
        left: auto;
        right: auto;
        top: auto;
        transform: none;
        width: 100%;
        margin-bottom: 20px;
    }
    
    .drag-drop-panel.collapsed, .employees-panel.collapsed {
        width: 100%;
        height: auto;
    }
    
    .drag-drop-panel.collapsed .panel-header, .employees-panel.collapsed .panel-header {
        flex-direction: row;
        justify-content: space-between;
    padding: 15px;
        height: auto;
        width: 100%;
        border-radius: 10px 10px 0 0;
        background: #f8f9fa;
    }
    
    .drag-drop-panel.collapsed .panel-header h6, .employees-panel.collapsed .panel-header h6 {
        display: block;
    }
    
    .drag-drop-panel.collapsed .panel-header button, .employees-panel.collapsed .panel-header button {
        display: block;
    }
    
    .drag-drop-panel.collapsed .collapsed-icon, .employees-panel.collapsed .collapsed-icon {
        display: none !important;
    }
}
</style>
{% endblock %}

{% block content %}

<!-- Shared panels -->
{% include 'shared/calendar/employees_panel.html' %}
{% include 'shared/calendar/quick_create_form.html' %}

<!-- Shared Calendar Grid -->
{% include 'shared/calendar/grid_unified.html' %}

{% endblock %}

{% block extra_js %}
<!-- Отключен старый calendar.js для тестирования -->
<!-- <script src="{{ url_for('static', path='js/shared/calendar.js') }}"></script> -->
<script src="{{ url_for('static', path='js/shared/calendar_panels.js') }}?v={{ range(1000, 9999) | random }}"></script>

<!-- Universal Calendar Integration -->
<script src="{{ url_for('static', path='js/shared/universal_calendar.js') }}?v={{ range(1000, 9999) | random }}"></script>
<script>
    // Инициализация универсального календаря для владельца
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded, CalendarPanels available:', typeof CalendarPanels !== 'undefined');
        // Инициализируем панели drag&drop
        if (typeof CalendarPanels !== 'undefined') {
            console.log('Initializing CalendarPanels for owner');
            window.calendarPanels = new CalendarPanels('owner');
            window.calendarPanels.init();
        } else {
            console.error('CalendarPanels not available!');
        }
        
        // Создаем экземпляр универсального календаря
        if (typeof UniversalCalendarManager !== 'undefined') {
            window.universalCalendar = new UniversalCalendarManager({
                currentDate: new Date({{ year }}, {{ month - 1 }}, 1),
                viewType: 'month',
                baseUrl: '/owner/calendar',
                userRole: 'owner',
                apiEndpoint: '/owner/calendar/api/data',
                onShiftClick: function(shiftId) {
                    console.log('Shift clicked:', shiftId);
                    if (shiftId.toString().startsWith('schedule_')) {
                        const scheduleId = shiftId.toString().replace('schedule_', '');
                        // Получаем object_id из данных календаря
                        let objectId = null;
                        if (window.calendarData && window.calendarData.shifts) {
                            const shift = window.calendarData.shifts.find(s => s.id === shiftId);
                            if (shift && shift.object_id) {
                                objectId = shift.object_id;
                            }
                        }
                        // Если не нашли в данных, делаем запрос к API
                        if (!objectId) {
                            fetch(`/owner/shifts/api/schedule/${scheduleId}/object-id`)
                                .then(response => response.json())
                                .then(data => {
                                    if (data.object_id) {
                                        window.location.href = `/owner/shifts/plan?object_id=${data.object_id}&return_to=/owner/calendar`;
                                    } else {
                                        window.location.href = `/owner/shifts/plan?return_to=/owner/calendar`;
                                    }
                                })
                                .catch(error => {
                                    console.error('Error fetching object_id:', error);
                                    window.location.href = `/owner/shifts/plan?return_to=/owner/calendar`;
                                });
                        } else {
                            window.location.href = `/owner/shifts/plan?object_id=${objectId}&return_to=/owner/calendar`;
                        }
                    } else {
                        window.location.href = `/owner/shifts/${shiftId}?shift_type=shift`;
                    }
                },
                onTimeslotClick: function(timeslotId) {
                    console.log('Timeslot clicked:', timeslotId);
                    showAddEmployeeModal(timeslotId);
                },
                onDataLoaded: function(calendarData) {
                    console.log('Calendar data loaded:', calendarData);
                    // Сохраняем данные глобально для использования в onShiftClick
                    window.calendarData = calendarData;
                    // Используем унифицированную функцию отрисовки
                    if (window.renderCalendarGrid) {
                        window.renderCalendarGrid(calendarData);
                    }
                }
            });
        }
    });
</script>

<script>
function notifyCalendar(message, type = 'info') {
    if (window.calendarPanels && typeof window.calendarPanels.showNotification === 'function') {
        window.calendarPanels.showNotification(message, type);
    } else {
        console.log(`[${type}] ${message}`);
    }
}

async function fetchTimeslotDetails(timeslotId) {
    try {
        const response = await fetch(`/owner/calendar/api/timeslot/${timeslotId}`, {
            credentials: 'include'
        });
        if (!response.ok) {
            return null;
        }
        return await response.json();
    } catch (error) {
        console.error('Ошибка получения данных тайм-слота:', error);
        return null;
    }
}

async function showAddEmployeeModal(timeslotId) {
    try {
        const timeslotElement = document.querySelector(`[data-timeslot-id="${timeslotId}"]`);
        let timeslotData = await fetchTimeslotDetails(timeslotId);
        let slotInfo = timeslotData && timeslotData.slot ? timeslotData.slot : {};

        const slotStart = slotInfo.start_time || (timeslotElement ? (timeslotElement.dataset.timeslotStartTime || null) : null);
        const slotEnd = slotInfo.end_time || (timeslotElement ? (timeslotElement.dataset.timeslotEndTime || null) : null);
        const maxEmployees = slotInfo.max_employees || (timeslotElement ? (timeslotElement.dataset.timeslotMaxEmployees || null) : null);
        let objectId = slotInfo.object_id || (timeslotElement ? (timeslotElement.dataset.timeslotObjectId || timeslotElement.dataset.objectId) : null);
        let objectName = slotInfo.object_name || (timeslotElement ? timeslotElement.dataset.timeslotObjectName : null);
        let timeRange = (slotStart && slotEnd) ? `${slotStart} - ${slotEnd}` :
            (timeslotElement ? `${timeslotElement.dataset.timeslotStartTime || ''} - ${timeslotElement.dataset.timeslotEndTime || ''}`.replace(/ - $/, '') : '');
        const slotDate = slotInfo.date || (timeslotElement ? timeslotElement.dataset.timeslotDate : '');

        if (!objectId) {
            notifyCalendar('Ошибка: не удалось определить объект тайм-слота', 'error');
            return;
        }

        const startValue = slotStart || '';
        const endValue = slotEnd || '';

        const modalHtml = `
            <div class="modal fade" id="addEmployeeToTimeslotModal" tabindex="-1" data-timeslot-id="${timeslotId}" data-object-id="${objectId}">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="bi bi-person-plus"></i> Добавить сотрудника в тайм-слот
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <div class="alert alert-secondary mb-3">
                                    <div><strong>Дата:</strong> ${slotDate || '—'}</div>
                                    <div><strong>Время:</strong> ${timeRange || '—'}</div>
                                    <div><strong>Объект:</strong> ${objectName || '—'}</div>
                                </div>
                                <label for="employeeSelectModal" class="form-label">Выберите сотрудника *</label>
                                <select class="form-select" id="employeeSelectModal" required>
                                    <option value="">Загрузка сотрудников...</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Время смены в тайм-слоте *</label>
                                <div class="row g-2 align-items-end">
                                    <div class="col">
                                        <label class="form-label form-label-sm text-muted">Начало</label>
                                        <input type="time" class="form-control" id="plannedShiftStart" value="${startValue}" ${startValue ? `min="${startValue}"` : ''} ${endValue ? `max="${endValue}"` : ''} required>
                                    </div>
                                    <div class="col">
                                        <label class="form-label form-label-sm text-muted">Окончание</label>
                                        <input type="time" class="form-control" id="plannedShiftEnd" value="${endValue}" ${startValue ? `min="${startValue}"` : ''} ${endValue ? `max="${endValue}"` : ''} required>
                                    </div>
                                </div>
                                <div class="form-text">
                                    Выберите промежуток в пределах тайм-слота. Максимум сотрудников: ${maxEmployees || 1}.
                                </div>
                            </div>
                            <div class="alert alert-info">
                                <i class="bi bi-info-circle"></i>
                                <strong>Совет:</strong> Вы также можете перетащить сотрудника из правой панели на тайм-слот.
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Отмена</button>
                            <button type="button" class="btn btn-success" id="confirmAddEmployeeBtn">
                                <i class="bi bi-check-lg"></i> Добавить
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        const existingModal = document.getElementById('addEmployeeToTimeslotModal');
        if (existingModal) {
            existingModal.remove();
        }

        document.body.insertAdjacentHTML('beforeend', modalHtml);

        const modalElement = document.getElementById('addEmployeeToTimeslotModal');
        modalElement.dataset.slotStartTime = startValue;
        modalElement.dataset.slotEndTime = endValue;
        if (maxEmployees) {
            modalElement.dataset.slotMaxEmployees = maxEmployees;
        }
        modalElement.addEventListener('hidden.bs.modal', () => {
            modalElement.remove();
        });

        const confirmButton = modalElement.querySelector('#confirmAddEmployeeBtn');
        confirmButton.addEventListener('click', () => addEmployeeToTimeslot(timeslotId));

        await loadEmployeesForModal(objectId);

        const modalInstance = new bootstrap.Modal(modalElement);
        modalInstance.show();
    } catch (error) {
        console.error('Ошибка подготовки модального окна:', error);
        notifyCalendar('Ошибка открытия окна назначения сотрудника', 'error');
    }
}

async function loadEmployeesForModal(objectId) {
    const select = document.getElementById('employeeSelectModal');
    if (!select) return;

    select.innerHTML = '<option value="">Загрузка сотрудников...</option>';

    try {
        const response = await fetch(`/owner/api/employees/for-object/${objectId}`, {
            credentials: 'include'
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        const employees = await response.json();

        if (!Array.isArray(employees)) {
            console.error('Неверный формат данных сотрудников:', employees);
            select.innerHTML = '<option value="">Ошибка: неверный формат данных</option>';
            return;
        }

        if (employees.length === 0) {
            select.innerHTML = '<option value="">Нет сотрудников с доступом к объекту</option>';
        } else {
            select.innerHTML = '<option value="">Выберите сотрудника</option>' +
                employees.map(emp => `<option value="${emp.id}">${emp.name}</option>`).join('');
        }
    } catch (error) {
        console.error('Ошибка загрузки сотрудников:', error);
        select.innerHTML = '<option value="">Ошибка загрузки сотрудников</option>';
    }
}

async function addEmployeeToTimeslot(timeslotId) {
    const modalElement = document.getElementById('addEmployeeToTimeslotModal');
    const select = document.getElementById('employeeSelectModal');
    const confirmButton = document.getElementById('confirmAddEmployeeBtn');
    const startInput = document.getElementById('plannedShiftStart');
    const endInput = document.getElementById('plannedShiftEnd');

    if (!modalElement || !select || !confirmButton) {
        notifyCalendar('Не удалось найти элементы окна назначения', 'error');
        return;
    }

    const employeeId = select.value;
    if (!employeeId) {
        notifyCalendar('Выберите сотрудника', 'error');
        return;
    }

    const slotStart = modalElement.dataset.slotStartTime || '';
    const slotEnd = modalElement.dataset.slotEndTime || '';
    const startTime = startInput ? startInput.value : slotStart;
    const endTime = endInput ? endInput.value : slotEnd;

    const toMinutes = (value) => {
        if (!value) return null;
        const [h, m] = value.split(':').map(Number);
        if (Number.isNaN(h) || Number.isNaN(m)) return null;
        return h * 60 + m;
    };

    const slotStartMinutes = toMinutes(slotStart);
    const slotEndMinutes = toMinutes(slotEnd);
    const startMinutes = toMinutes(startTime);
    const endMinutes = toMinutes(endTime);

    if (startMinutes === null || endMinutes === null) {
        notifyCalendar('Укажите время начала и окончания смены', 'error');
        return;
    }

    if (startMinutes >= endMinutes) {
        notifyCalendar('Время окончания должно быть позже времени начала', 'error');
        return;
    }

    if (slotStartMinutes !== null && startMinutes < slotStartMinutes) {
        notifyCalendar(`Время начала должно быть не раньше ${slotStart}`, 'error');
        return;
    }

    if (slotEndMinutes !== null && endMinutes > slotEndMinutes) {
        notifyCalendar(`Время окончания должно быть не позже ${slotEnd}`, 'error');
        return;
    }

    confirmButton.disabled = true;
    confirmButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Назначение...';

    try {
        const response = await fetch('/owner/api/calendar/plan-shift', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                timeslot_id: Number(timeslotId),
                employee_id: Number(employeeId),
                start_time: startTime,
                end_time: endTime
            })
        });

        let result = {};
        try {
            result = await response.json();
        } catch (jsonError) {
            console.warn('Не удалось разобрать ответ планирования', jsonError);
        }

        if (!response.ok || result.success === false) {
            const message = result.detail || result.message || 'Ошибка планирования смены';
            throw new Error(message);
        }

        const modalInstance = bootstrap.Modal.getInstance(modalElement);
        if (modalInstance) {
            modalInstance.hide();
        }

        notifyCalendar(result.message || 'Смена успешно запланирована', 'success');

        if (window.universalCalendar && typeof window.universalCalendar.refresh === 'function') {
            window.universalCalendar.refresh();
        } else {
            setTimeout(() => window.location.reload(), 800);
        }
    } catch (error) {
        console.error('Ошибка планирования смены:', error);
        notifyCalendar(error.message || 'Ошибка планирования смены', 'error');
    } finally {
        confirmButton.disabled = false;
        confirmButton.innerHTML = '<i class="bi bi-check-lg"></i> Добавить';
    }
}

// Перехватываем клики по тайм-слотам на стадии захвата, чтобы избежать двойного открытия модалок
document.addEventListener('click', function(e) {
    const actionButton = e.target.closest('.timeslot-actions button');
    if (actionButton) {
        return;
    }
    const timeslotElement = e.target.closest('.timeslot-item');
    if (!timeslotElement) {
        return;
    }
    const timeslotId = timeslotElement.dataset.timeslotId;
    if (!timeslotId) {
        return;
    }
    e.stopPropagation();
    e.preventDefault();
    if (window.universalCalendar && typeof window.universalCalendar.onTimeslotClick === 'function') {
        window.universalCalendar.onTimeslotClick(timeslotId);
    }
}, true);

// Экспорт данных календаря для JS-логики занятости
window.calendar_weeks = {{ calendar_weeks | tojson }};

// Define callback functions before using them
function showShiftDetails(shiftId) {
    if (shiftId.toString().startsWith('schedule_')) {
        const scheduleId = shiftId.toString().replace('schedule_', '');
        window.location.href = `/owner/shifts/${scheduleId}?shift_type=schedule`;
    } else {
        window.location.href = `/owner/shifts/${shiftId}?shift_type=shift`;
    }
}

function showTimeslotDetails(timeslotId) {
    window.location.href = `/owner/timeslots/${timeslotId}`;
}

function showDateDetails(date) {}

// Initialize calendar panels for owner role (use global instance only)
// Already initialized above as window.calendarPanels

// Добавляем обработчик клика на день календаря для быстрого создания тайм-слота
document.addEventListener('click', function(e) {
    const calendarDay = e.target.closest('.calendar-day');
    if (calendarDay && !e.target.closest('.timeslot-item') && !e.target.closest('.shift-item')) {
        const dateStr = calendarDay.dataset.date;
        if (dateStr && !calendarDay.classList.contains('other-month')) {
            // Открываем форму быстрого создания тайм-слота
            if (window.calendarPanels) {
                window.calendarPanels.showQuickCreateForm(null, dateStr);
            }
        }
    }
});

// Override universal calendar manager methods
if (window.universalCalendar) {
    // Назначение сотрудника на тайм-слот (drag&drop)
    window.universalCalendar.assignEmployeeToTimeslot = async function(employeeId, timeslotId) {
    try {
        console.log(`Planning shift: employeeId=${employeeId}, timeslotId=${timeslotId}`);
        
        // Используем данные из памяти вместо повторного запроса
        const employees = window.calendarPanels?.employeesData || [];
        if (employees.length === 0) {
            // Если данных нет в памяти, загружаем
            const employeeResponse = await fetch(`/owner/api/employees`);
            if (!employeeResponse.ok) {
                throw new Error(`HTTP ${employeeResponse.status}: ${employeeResponse.statusText}`);
            }
            employees = await employeeResponse.json();
        }
        
        const employee = employees.find(emp => emp.id == parseInt(employeeId));
        if (!employee) {
            console.log(`Employee not found: ${employeeId}`);
            calendarPanels.showNotification('Сотрудник не найден', 'error');
            return;
        }
        console.log(`Found employee:`, employee);
        const timeslotResponse = await fetch(`/owner/calendar/api/timeslot/${timeslotId}`);
        if (!timeslotResponse.ok) {
            throw new Error(`HTTP ${timeslotResponse.status}: ${timeslotResponse.statusText}`);
        }
        const timeslot = await timeslotResponse.json();
        if (!timeslot) {
            console.log(`Timeslot not found: ${timeslotId}`);
            calendarPanels.showNotification('Тайм-слот не найден', 'error');
            return;
        }
        console.log(`Found timeslot:`, timeslot);
        const timeStr = timeslot.slot ? `${timeslot.slot.start_time} - ${timeslot.slot.end_time}` : 'время не определено';
        const requestData = { timeslot_id: Number(timeslotId), employee_id: Number(employeeId) };
        console.log(`Sending request:`, requestData);
        const planResp = await fetch('/owner/api/calendar/plan-shift', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });
        const planData = await planResp.json().catch(() => ({}));
        if (!planResp.ok || planData.success === false) {
            const detail = planData && (planData.detail || planData.message);
            throw new Error(detail || `Не удалось запланировать смену (HTTP ${planResp.status})`);
        }
        calendarPanels.showNotification(`Сотрудник ${employee.name} назначен на тайм-слот ${timeStr}`, 'success');
        // Календарь обновится автоматически благодаря очистке кэша на сервере
        if (window.universalCalendar) {
            window.universalCalendar.refresh();
        }
    } catch (error) {
        console.error('Error assigning employee:', error);
        calendarPanels.showNotification(`Ошибка назначения сотрудника: ${error.message}`, 'error');
    }
};
}

// NOTE: calendarPanels.init() уже вызван в основном DOMContentLoaded выше (строка 258)
// Убрана дублирующая инициализация панелей

// Initialize timeslot occupancy after calendar loads
setTimeout(() => {
    initializeTimeslotOccupancy();
}, 1000);

// Автоматический скролл к текущему дню при загрузке
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const todayElement = document.querySelector('.calendar-day.today');
        if (todayElement) {
            todayElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 500);
});

// Initialize timeslot occupancy
function initializeTimeslotOccupancy() {
    // Собираем смены только из данных страницы, не из DOM
    const scheduledShifts = [];

    // Из window.calendarData (если есть)
    if (window.calendarData && Array.isArray(window.calendarData.scheduled_shifts)) {
        window.calendarData.scheduled_shifts.forEach(shift => {
            if (shift && shift.time_slot_id && shift.status && shift.status !== 'cancelled') {
                scheduledShifts.push({
                    id: shift.id,
                    time_slot_id: Number(shift.time_slot_id),
                    status: shift.status,
                    planned_start: shift.planned_start || shift.start_time || null,
                    planned_end: shift.planned_end || shift.end_time || null,
                    start_time: shift.start_time || null,
                    end_time: shift.end_time || null,
                    date: shift.date || shift.slot_date || null
                });
            }
        });
    }

    // Из window.calendar_weeks (если есть)
    if (window.calendar_weeks && Array.isArray(window.calendar_weeks)) {
        window.calendar_weeks.forEach(week => {
            week.forEach(day => {
                if (day && Array.isArray(day.shifts)) {
                    day.shifts.forEach(shift => {
                        if (shift && shift.time_slot_id && shift.status && shift.status !== 'cancelled') {
                            scheduledShifts.push({
                                id: shift.id,
                                time_slot_id: Number(shift.time_slot_id),
                                status: shift.status,
                                planned_start: shift.planned_start || shift.start_time || null,
                                planned_end: shift.planned_end || shift.end_time || null,
                                start_time: shift.start_time || null,
                                end_time: shift.end_time || null,
                                date: shift.date || shift.slot_date || null
                            });
                        }
                    });
                }
            });
        });
    }

    console.log('Found scheduledShifts:', scheduledShifts.length);
    console.log('window.calendar_weeks exists:', !!window.calendar_weeks);
    console.log('window.calendarData exists:', !!window.calendarData);
    if (window.calendar_weeks && window.calendar_weeks.length > 0) {
        console.log('First week shifts:', window.calendar_weeks[0].map(day => day.shifts ? day.shifts.length : 0));
    }

    // Если смен нет в данных — подтягиваем с сервера статусы тайм-слотов как fallback
    const applyOccupancy = (shifts, detailedShifts = []) => {
        const timeslotInfoMap = {};
        if (window.calendarData && Array.isArray(window.calendarData.timeslots)) {
            window.calendarData.timeslots.forEach(ts => {
                timeslotInfoMap[Number(ts.id)] = ts;
            });
        }

        const normalizedShifts = [];
        const seenShiftKeys = new Set();

        const normalizeShiftEntry = (shift) => {
            if (!shift) {
                return null;
            }
            const timeSlotId = shift.time_slot_id || shift.timeslot_id;
            if (!timeSlotId) {
                return null;
            }
            const status = shift.status || shift.shift_status;
            if (status === 'cancelled') {
                return null;
            }

            let startIso = shift.planned_start || shift.start_time || null;
            let endIso = shift.planned_end || shift.end_time || null;
            const datePart = shift.date || shift.slot_date || shift.day || null;
            if ((!startIso || !endIso) && datePart && shift.start_time && shift.end_time) {
                startIso = `${datePart}T${shift.start_time}`;
                endIso = `${datePart}T${shift.end_time}`;
            }

            if (!startIso || !endIso) {
                return null;
            }

            const startDate = new Date(startIso);
            const endDate = new Date(endIso);
            if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
                return null;
            }

            const key = `${timeSlotId}_${startDate.getTime()}_${endDate.getTime()}`;
            if (seenShiftKeys.has(key)) {
                return null;
            }
            seenShiftKeys.add(key);

            return {
                time_slot_id: Number(timeSlotId),
                status,
                startMinutes: startDate.getHours() * 60 + startDate.getMinutes(),
                endMinutes: endDate.getHours() * 60 + endDate.getMinutes()
            };
        };

        if (Array.isArray(detailedShifts)) {
            detailedShifts.forEach(shift => {
                const normalized = normalizeShiftEntry(shift);
                if (normalized) {
                    normalizedShifts.push(normalized);
                }
            });
        }

        if (Array.isArray(shifts)) {
            shifts.forEach(shift => {
                const normalized = normalizeShiftEntry(shift);
                if (normalized) {
                    normalizedShifts.push(normalized);
                }
            });
        }

        const shiftsByTimeslot = {};
        normalizedShifts.forEach(shift => {
            shiftsByTimeslot[shift.time_slot_id] = shiftsByTimeslot[shift.time_slot_id] || [];
            shiftsByTimeslot[shift.time_slot_id].push(shift);
        });

        const toMinutes = (timeStr) => {
            if (!timeStr || typeof timeStr !== 'string') {
                return null;
            }
            const [h, m] = timeStr.split(':').map(Number);
            if (Number.isNaN(h) || Number.isNaN(m)) {
                return null;
            }
            return h * 60 + m;
        };

        const timeslotElements = document.querySelectorAll('.timeslot-item[data-timeslot-id]');
        const timeslotsByObject = {};

        // Группируем тайм-слоты по объектам
        timeslotElements.forEach(timeslot => {
            const timeslotId = parseInt(timeslot.dataset.timeslotId);
            const objectId = parseInt(timeslot.dataset.objectId);
            const maxEmployees = parseFloat(timeslot.dataset.timeslotMaxEmployees || timeslot.dataset.maxEmployees) || 1;

            if (!timeslotsByObject[objectId]) {
                timeslotsByObject[objectId] = [];
            }

            timeslotsByObject[objectId].push({
                element: timeslot,
                id: timeslotId,
                maxEmployees: maxEmployees
            });
        });

        // Для каждого объекта обрабатываем его тайм-слоты
        Object.keys(timeslotsByObject).forEach(objectId => {
            const objectTimeslots = timeslotsByObject[objectId];

            objectTimeslots.forEach(timeslot => {
                const timeslotId = timeslot.id;
                const maxEmployees = timeslot.maxEmployees;

                const slotInfo = timeslotInfoMap[timeslotId] || {};
                const slotStartStr = timeslot.element.dataset.timeslotStartTime || slotsafe(slotInfo.start_time);
                const slotEndStr = timeslot.element.dataset.timeslotEndTime || slotsafe(slotInfo.end_time);

                function slotsafe(value) {
                    if (!value || typeof value !== 'string') {
                        return null;
                    }
                    return value.includes(':') ? value.slice(0,5) : value;
                }

                const slotStartMinutes = toMinutes(slotStartStr);
                const slotEndMinutes = toMinutes(slotEndStr);
                const slotDurationMinutes = (slotStartMinutes !== null && slotEndMinutes !== null) ? (slotEndMinutes - slotStartMinutes) : null;

                let occupancyFraction = null;

                if (slotDurationMinutes && slotDurationMinutes > 0 && maxEmployees > 0) {
                    const detailedForTimeslot = shiftsByTimeslot[timeslotId] || [];
                    let totalMinutes = 0;

                    detailedForTimeslot.forEach(shift => {
                        const shiftStart = shift.startMinutes;
                        const shiftEnd = shift.endMinutes;
                        if (shiftStart === null || shiftEnd === null) {
                            return;
                        }
                        const overlapStart = Math.max(slotStartMinutes, shiftStart);
                        const overlapEnd = Math.min(slotEndMinutes, shiftEnd);
                        if (overlapEnd > overlapStart) {
                            totalMinutes += overlapEnd - overlapStart;
                        }
                    });

                    const capacityMinutes = slotDurationMinutes * maxEmployees;
                    occupancyFraction = capacityMinutes > 0 ? Math.min(1, totalMinutes / capacityMinutes) : 0;
                }

                if (occupancyFraction === null) {
                    // Fallback: используем подсчёт смен, если нет данных по длительности
                    const shiftsForThisTimeslot = shifts.filter(shift =>
                        Number(shift.time_slot_id) === Number(timeslotId) && shift.status !== 'cancelled' && shift.status !== 'completed'
                    );
                    occupancyFraction = Math.min(1, shiftsForThisTimeslot.length / maxEmployees);
                }

                const availableFraction = Math.max(0, 1 - occupancyFraction);
                const shouldHide = occupancyFraction >= 0.999;

                if (shouldHide) {
                    timeslot.element.style.display = 'none';
                } else {
                    timeslot.element.style.display = '';
                    const occupancyIndicator = timeslot.element.querySelector('.timeslot-occupancy');
                    const occupancyBadge = timeslot.element.querySelector('.timeslot-badge');
                    const labelText = `${availableFraction.toFixed(2)}/${maxEmployees}`;

                    if (occupancyIndicator) {
                        const textNode = occupancyIndicator.querySelector('.occupancy-text');
                        if (textNode) {
                            textNode.textContent = labelText;
                        } else {
                            occupancyIndicator.textContent = labelText;
                        }
                        if (availableFraction >= 0.999) {
                            occupancyIndicator.className = 'timeslot-occupancy available';
                        } else if (availableFraction <= 0.001) {
                            occupancyIndicator.className = 'timeslot-occupancy full';
                        } else {
                            occupancyIndicator.className = 'timeslot-occupancy partial';
                        }
                    }

                    if (occupancyBadge) {
                        occupancyBadge.textContent = labelText;
                    }
                }
            });
        });
    };

    // Всегда применяем логику к найденным сменам
    const detailedCalendarShifts = Array.isArray(window.calendarData?.shifts) ? window.calendarData.shifts : [];
    if (scheduledShifts.length > 0 || detailedCalendarShifts.length > 0) {
        applyOccupancy(scheduledShifts, detailedCalendarShifts);
    } else {
        // Если смен нет в данных — подтягиваем с сервера статусы тайм-слотов как fallback
        const year = {{ year }};
        const month = {{ month }};
        fetch(`/owner/calendar/api/timeslots-status?year=${year}&month=${month}`)
            .then(r => r.json())
            .then(data => {
                const shifts = [];
                const detailed = [];
                (data || []).forEach(item => {
                    const date = item.date || item.slot_date || null;
                    // planned shifts
                    (item.scheduled_shifts || []).forEach(s => {
                        if (s.status !== 'cancelled') {
                            shifts.push({ time_slot_id: item.slot_id, status: s.status });
                            detailed.push({
                                time_slot_id: item.slot_id,
                                status: s.status,
                                date: date,
                                start_time: s.start_time,
                                end_time: s.end_time
                            });
                        }
                    });
                    // actual shifts
                    (item.actual_shifts || []).forEach(s => {
                        if (s.status !== 'cancelled') {
                            shifts.push({ time_slot_id: item.slot_id, status: s.status });
                            detailed.push({
                                time_slot_id: item.slot_id,
                                status: s.status,
                                date: date,
                                start_time: s.start_time,
                                end_time: s.end_time
                            });
                        }
                    });
                });
                applyOccupancy(shifts, detailed);
            })
            .catch(() => applyOccupancy([]));
    }
}

// Проверяем доступность функции фильтрации
console.log('Calendar loaded, filterByObject available:', typeof window.filterByObject === 'function');


// CSS для календаря планирования
const planShiftCSS = `
<style>
.calendar-container {
    max-height: 400px;
    overflow-y: auto;
}

.calendar-grid-plan {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 1px;
    background: #dee2e6;
    border-radius: 8px;
    overflow: hidden;
}

.calendar-header-plan {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    background: #f8f9fa;
    font-weight: bold;
    text-align: center;
}

.day-header {
    padding: 8px;
    background: #e9ecef;
    border-bottom: 1px solid #dee2e6;
}

.calendar-days-plan {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 1px;
}

.calendar-day {
    min-height: 60px;
    background: white;
    padding: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.calendar-day:hover:not(.disabled) {
    background: #f8f9fa;
    transform: scale(1.02);
}

.calendar-day.available-timeslot {
    background: #e8f5e8;
}

.calendar-day.selected {
    background: #28a745 !important;
    color: white;
}

.calendar-day.disabled {
    background: #f8f9fa;
    color: #6c757d;
    cursor: not-allowed;
}

.day-number {
    font-weight: bold;
    font-size: 14px;
}

.free-slots {
    font-size: 10px;
    color: #28a745;
    font-weight: bold;
}

.calendar-day.selected .free-slots {
    color: white;
}

@media (max-width: 768px) {
    .calendar-day {
        min-height: 50px;
        padding: 2px;
    }
    
    .day-number {
        font-size: 12px;
    }
    
    .free-slots {
        font-size: 9px;
    }
}
</style>
`;

// Добавляем CSS в head
document.head.insertAdjacentHTML('beforeend', planShiftCSS);
</script>

{% endblock %}
