{% extends "owner/base_owner.html" %}

{% block title %}Планирование смен{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1 class="h3 mb-0">
                    <i class="bi bi-calendar-plus"></i> Планирование смен
                </h1>
                <a href="{{ return_to }}" class="btn btn-outline-secondary">
                    <i class="bi bi-arrow-left me-1"></i>Назад
                </a>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <form id="planShiftForm">
                        <!-- Выбор объекта и сотрудника -->
                        <div class="row g-3 mb-4">
                            <div class="col-md-6">
                                <label for="planObjectSelect" class="form-label">Объект <span class="text-danger">*</span></label>
                                <select class="form-select" id="planObjectSelect" required>
                                    <option value="">Выберите объект</option>
                                    {% for obj in objects %}
                                    <option value="{{ obj.id }}" {% if selected_object_id == obj.id %}selected{% endif %}>{{ obj.name }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                            <div class="col-md-6">
                                <label for="planEmployeeSelect" class="form-label">Сотрудник <span class="text-danger">*</span></label>
                                <select class="form-select" id="planEmployeeSelect" required>
                                    <option value="">Выберите сотрудника</option>
                                </select>
                            </div>
                        </div>

                        <!-- Календарь -->
                        <div class="calendar-container">
                            <div class="calendar-header d-flex justify-content-between align-items-center mb-3">
                                <button type="button" class="btn btn-outline-secondary" id="prevMonth">
                                    <i class="bi bi-chevron-left"></i>
                                </button>
                                <h5 class="mb-0 text-primary" id="calendarMonthYear"></h5>
                                <button type="button" class="btn btn-outline-secondary" id="nextMonth">
                                    <i class="bi bi-chevron-right"></i>
                                </button>
                            </div>
                            
                            <div class="calendar-grid" id="planShiftCalendar">
                                <!-- Календарь будет загружен через JavaScript -->
                            </div>
                        </div>
                    </form>
                </div>
                <div class="card-footer d-flex flex-column flex-md-row justify-content-between gap-3 align-items-md-center">
                    <div id="selectedSlotsInfo" class="selected-info">
                        <div class="info-line">
                            <i class="bi bi-calendar-plus"></i>
                            Новые смены: <strong><span id="selectedTimeslotsCount">0</span></strong>
                        </div>
                        <div class="info-line">
                            <i class="bi bi-check-circle"></i>
                            Оставить запланированными: <strong><span id="selectedPlannedCount">0</span></strong>
                        </div>
                        <div class="info-line text-warning" id="cancelInfoLine">
                            <i class="bi bi-x-circle"></i>
                            Отменить смен: <strong><span id="cancelPlannedCount">0</span></strong>
                        </div>
                    </div>
                    <div>
                        <a href="{{ return_to }}" class="btn btn-secondary">Отмена</a>
                        <button type="button" class="btn btn-success" id="confirmPlanShift" disabled>
                            <i class="bi bi-calendar-check"></i> Запланировать смены
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- CSS для календаря планирования -->
<style>
.calendar-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 4px;
    margin-bottom: 12px;
}

.calendar-weekday {
    text-align: center;
    font-weight: 600;
    font-size: 0.85em;
    color: #6c757d;
    padding: 8px 4px;
}

.calendar-days {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 4px;
}

.calendar-day {
    min-height: 80px;
    background: white;
    padding: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    flex-direction: column;
    border: 1px solid #dee2e6;
}

.calendar-day:hover:not(.disabled) {
    background: #f8f9fa;
}

.calendar-day.has-timeslots {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
}

.calendar-day.selected {
    background: #e3f2fd !important;
    border: 2px solid #2196f3;
}

.calendar-day.disabled {
    background: #f8f9fa;
    color: #6c757d;
    cursor: not-allowed;
}

.timeslot {
    margin: 2px 0;
    padding: 2px 4px;
    border-radius: 3px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.timeslot.available {
    background: #e8f5e8;
    border: 1px solid #4caf50;
    color: #2e7d32;
}

.timeslot.occupied {
    background: #ffebee;
    border: 1px solid #f44336;
    color: #c62828;
}

.timeslot:hover {
    transform: scale(1.05);
}

.timeslot.selected {
    background: #2196f3 !important;
    color: white !important;
    border-color: #1976d2 !important;
}

.planned-shift {
    position: relative;
    margin: 2px 0;
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 12px;
    background: #fff;
    border: 1px solid rgba(33, 150, 243, 0.2);
    color: #1565c0;
    cursor: pointer;
    transition: all 0.2s ease;
}

.planned-shift:hover {
    transform: scale(1.02);
    border-color: rgba(33, 150, 243, 0.5);
    box-shadow: 0 4px 12px rgba(33, 150, 243, 0.12);
}

.planned-shift.selected {
    background: #e3f2fd;
    border-color: #1976d2;
    color: #0d47a1;
}

.planned-shift .shift-badge {
    position: absolute;
    top: 0;
    right: 0;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    font-weight: 600;
    padding: 2px 6px;
    border-radius: 0 10px 0 10px;
    color: #fff;
    background: rgba(30, 136, 229, 0.9);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    width: fit-content;
    z-index: 2;
}

.planned-shift-time {
    font-weight: 600;
    font-size: 14px;
}

.planned-shift-object {
    font-size: 11px;
    opacity: 0.7;
}

.selected-info {
    display: none;
    background: #f5f9ff;
    border: 1px solid rgba(33, 150, 243, 0.2);
    border-radius: 8px;
    padding: 8px 14px;
    color: #0d47a1;
    font-size: 13px;
    line-height: 1.4;
}

.selected-info .info-line {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 4px;
}

.selected-info .info-line:last-child {
    margin-bottom: 0;
}

.selected-info .info-line.text-warning {
    color: #d97706;
}

.timeslot-time {
    font-weight: bold;
    font-size: 14px;
}

.timeslot-slots {
    font-size: 12px;
    opacity: 0.8;
}

.empty-message {
    font-size: 13px;
    color: #6c757d;
    text-align: center;
    margin-top: 4px;
}

.no-slots {
    font-size: 12px;
    color: #dc3545;
    text-align: center;
    margin-top: 4px;
    font-weight: bold;
}

.day-number {
    font-weight: bold;
    font-size: 14px;
}
</style>

<script>
// Данные для планирования
const returnToUrl = "{{ return_to }}";
const selectedObjectId = {{ selected_object_id or 'null' }};
let selectedTimeslots = new Set();
let availableTimeslots = [];
let calendarShifts = [];
let employeePlannedShifts = [];
let selectedPlannedShiftIds = new Set();
let initialPlannedShiftIds = new Set();
let currentEmployeeId = null;
let currentMonth = new Date().getMonth();
let currentYear = new Date().getFullYear();

// Загрузка объектов при инициализации
document.addEventListener('DOMContentLoaded', function() {
    // Если объект предзаполнен, загружаем сотрудников
    if (selectedObjectId) {
        const objectSelect = document.getElementById('planObjectSelect');
        objectSelect.value = selectedObjectId;
        loadEmployeesForObject(selectedObjectId);
    }
    
    // Создаем пустой календарь сразу
    createEmptyCalendar();
    updateSelectedSlotsInfo();
    
    // Обработчики навигации по месяцам
    document.getElementById('prevMonth')?.addEventListener('click', function() {
        currentMonth--;
        if (currentMonth < 0) {
            currentMonth = 11;
            currentYear--;
        }
        updateCalendar();
    });
    
    document.getElementById('nextMonth')?.addEventListener('click', function() {
        currentMonth++;
        if (currentMonth > 11) {
            currentMonth = 0;
            currentYear++;
        }
        updateCalendar();
    });
    
    // Обработчик изменения объекта
    document.getElementById('planObjectSelect')?.addEventListener('change', function() {
        if (this.value) {
            currentEmployeeId = null;
            selectedTimeslots.clear();
            employeePlannedShifts = [];
            selectedPlannedShiftIds.clear();
            initialPlannedShiftIds.clear();
            loadEmployeesForObject(this.value);
            clearCalendar();
            updateSelectedSlotsInfo();
        } else {
            currentEmployeeId = null;
            selectedTimeslots.clear();
            employeePlannedShifts = [];
            selectedPlannedShiftIds.clear();
            initialPlannedShiftIds.clear();
            clearCalendar();
            clearEmployees();
            updateSelectedSlotsInfo();
        }
    });
    
    // Обработчик изменения сотрудника
    document.getElementById('planEmployeeSelect')?.addEventListener('change', function() {
        const objectId = document.getElementById('planObjectSelect').value;
        if (this.value && objectId) {
            currentEmployeeId = Number(this.value);
            selectedTimeslots.clear();
            employeePlannedShifts = [];
            selectedPlannedShiftIds.clear();
            initialPlannedShiftIds.clear();
            loadTimeslotsForObject(objectId);
            updateSelectedSlotsInfo();
        } else {
            currentEmployeeId = null;
            selectedTimeslots.clear();
            employeePlannedShifts = [];
            selectedPlannedShiftIds.clear();
            initialPlannedShiftIds.clear();
            clearCalendar();
            updateSelectedSlotsInfo();
        }
    });
    
    // Обработчик подтверждения планирования
    document.getElementById('confirmPlanShift')?.addEventListener('click', confirmPlanShift);
});

// Загрузка сотрудников для конкретного объекта
async function loadEmployeesForObject(objectId) {
    try {
        const response = await fetch(`/owner/api/employees/for-object/${objectId}`);
        const employees = await response.json();
        
        const select = document.getElementById('planEmployeeSelect');
        select.innerHTML = '<option value="">Выберите сотрудника</option>';
        
        if (Array.isArray(employees)) {
            employees.forEach(emp => {
                const option = document.createElement('option');
                option.value = emp.id;
                option.textContent = emp.name;
                select.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Ошибка загрузки сотрудников для объекта:', error);
    }
}

// Очистка списка сотрудников
function clearEmployees() {
    const select = document.getElementById('planEmployeeSelect');
    select.innerHTML = '<option value="">Выберите сотрудника</option>';
}

// Создание пустого календаря
function createEmptyCalendar() {
    const calendarEl = document.getElementById('planShiftCalendar');
    const firstDay = new Date(currentYear, currentMonth, 1);
    const lastDay = new Date(currentYear, currentMonth + 1, 0);
    
    const firstMonday = new Date(firstDay);
    firstMonday.setDate(firstDay.getDate() - firstDay.getDay() + 1);
    
    const daysOfWeek = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
    
    let html = `
        <div class="calendar-weekdays">
            ${daysOfWeek.map(day => `<div class="calendar-weekday">${day}</div>`).join('')}
        </div>
        <div class="calendar-days">
    `;
    
    for (let i = 0; i < 35; i++) {
        const date = new Date(firstMonday);
        date.setDate(firstMonday.getDate() + i);
        
        const isCurrentMonth = date.getMonth() === currentMonth;
        const dateStr = formatDateForAPI(date);
        
        html += `
            <div class="calendar-day ${isCurrentMonth ? '' : 'disabled'}" data-date="${dateStr}">
                <div class="day-number">${date.getDate()}</div>
                <div class="empty-message">Выберите сотрудника</div>
            </div>
        `;
    }
    
    html += '</div>';
    calendarEl.innerHTML = html;
}

// Очистка календаря
function clearCalendar(resetPlanned = true) {
    createEmptyCalendar();
    availableTimeslots = [];
    selectedTimeslots.clear();
    if (resetPlanned) {
        employeePlannedShifts = [];
        selectedPlannedShiftIds.clear();
        initialPlannedShiftIds.clear();
    }
}

// Загрузка тайм-слотов для объекта
async function loadTimeslotsForObject(objectId) {
    try {
        if (!objectId) {
            availableTimeslots = [];
            employeePlannedShifts = [];
            selectedPlannedShiftIds.clear();
            initialPlannedShiftIds.clear();
            updateCalendar();
            updateSelectedSlotsInfo();
            return;
        }

        const objectNumericId = Number(objectId);
        if (Number.isNaN(objectNumericId)) {
            availableTimeslots = [];
            employeePlannedShifts = [];
            selectedPlannedShiftIds.clear();
            initialPlannedShiftIds.clear();
            updateCalendar();
            updateSelectedSlotsInfo();
            return;
        }

        const today = new Date();
        const startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const endDate = new Date(today.getFullYear(), today.getMonth() + 2, 0);
        selectedTimeslots.clear();
        
        const response = await fetch(`/owner/calendar/api/data?start_date=${formatDateForAPI(startDate)}&end_date=${formatDateForAPI(endDate)}&object_ids=${objectId}`);
        const data = await response.json();
        
        const timeslots = Array.isArray(data.timeslots) ? data.timeslots : [];
        calendarShifts = Array.isArray(data.shifts) ? data.shifts : [];

        const relevantShifts = calendarShifts.filter(shift => Number(shift.object_id) === objectNumericId);

        availableTimeslots = timeslots
            .filter(ts => Number(ts.object_id) === objectNumericId)
            .map(ts => {
                const status = (ts.status || '').toLowerCase();
                const freeInterval = calculateFirstFreeInterval(ts, relevantShifts);
                
                if (!freeInterval) {
                    return null;
                }
                
                return {
                    ...ts,
                    status,
                    first_free_start: freeInterval.startStr,
                    first_free_end: freeInterval.endStr,
                    first_free_duration: freeInterval.durationMinutes
                };
            })
            .filter(Boolean)
            .sort((a, b) => {
                const dateA = new Date((a.date || a.slot_date || a.start_date) + 'T00:00:00');
                const dateB = new Date((b.date || b.slot_date || b.start_date) + 'T00:00:00');
                if (dateA.getTime() === dateB.getTime()) {
                    const timeA = timeStringToMinutes(a.first_free_start || a.start_time || a.start_time_str || '00:00') || 0;
                    const timeB = timeStringToMinutes(b.first_free_start || b.start_time || b.start_time_str || '00:00') || 0;
                    return timeA - timeB;
                }
                return dateA - dateB;
            });

        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);

        if (currentEmployeeId && !Number.isNaN(Number(currentEmployeeId))) {
            const employeeIdNumeric = Number(currentEmployeeId);
            const employeeRelevantShifts = relevantShifts.filter(
                shift => Number(shift.user_id) === employeeIdNumeric && shift.schedule_id !== undefined && shift.schedule_id !== null
            );

            employeePlannedShifts = employeeRelevantShifts
                .filter(shift => {
                    const shiftType = (shift.shift_type || '').toLowerCase();
                    if (shiftType !== 'planned') {
                        return false;
                    }
                    const status = (shift.status || '').toLowerCase();
                    if (!ALLOWED_SHIFT_STATUSES.has(status)) {
                        return false;
                    }
                    const endISO = shift.planned_end || shift.end_time || shift.start_time;
                    if (!endISO) {
                        return false;
                    }
                    const endDate = new Date(endISO);
                    if (Number.isNaN(endDate.getTime())) {
                        return false;
                    }
                    return endDate >= todayStart;
                })
                .map(shift => {
                    const scheduleId = Number(shift.schedule_id);
                    if (Number.isNaN(scheduleId)) {
                        return null;
                    }
                    const shiftDateStr = getISODateString(shift.planned_start || shift.start_time);
                    if (!shiftDateStr) {
                        return null;
                    }
                    const startLabel = formatISOTimeToLocal(shift.planned_start || shift.start_time);
                    const endLabel = formatISOTimeToLocal(shift.planned_end || shift.end_time);
                    return {
                        schedule_id: scheduleId,
                        time_slot_id: shift.time_slot_id !== undefined && shift.time_slot_id !== null ? Number(shift.time_slot_id) : null,
                        date: shiftDateStr,
                        start_time: startLabel,
                        end_time: endLabel,
                        time_range: `${startLabel || '—'} - ${endLabel || '—'}`,
                        object_name: shift.object_name || '',
                        status: shift.status || 'planned',
                        original: shift
                    };
                })
                .filter(Boolean)
                .sort((a, b) => {
                    if (a.date === b.date) {
                        const timeA = timeStringToMinutes(a.start_time) || 0;
                        const timeB = timeStringToMinutes(b.start_time) || 0;
                        return timeA - timeB;
                    }
                    const dateA = new Date(`${a.date}T00:00:00`);
                    const dateB = new Date(`${b.date}T00:00:00`);
                    return dateA - dateB;
                });
        } else {
            employeePlannedShifts = [];
        }

        initialPlannedShiftIds = new Set(employeePlannedShifts.map(shift => shift.schedule_id));
        selectedPlannedShiftIds = new Set(initialPlannedShiftIds);
        
        updateCalendar();
        updateSelectedSlotsInfo();
        
    } catch (error) {
        console.error('Ошибка загрузки тайм-слотов:', error);
        alert('Ошибка загрузки тайм-слотов: ' + error.message);
        updateSelectedSlotsInfo();
    }
}

// Форматирование даты для API
function formatDateForAPI(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

function timeStringToMinutes(value) {
    if (!value || typeof value !== 'string') {
        return null;
    }
    const [hoursStr, minutesStr] = value.split(':');
    const hours = Number(hoursStr);
    const minutes = Number(minutesStr);
    if (Number.isNaN(hours) || Number.isNaN(minutes)) {
        return null;
    }
    return hours * 60 + minutes;
}

function minutesToTime(minutes) {
    const total = Math.max(0, Math.floor(minutes));
    const hours = Math.floor(total / 60);
    const mins = total % 60;
    return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
}

function formatFreeMinutes(value) {
    const minutes = Math.max(0, Math.floor(Number(value) || 0));
    const hours = Math.floor(minutes / 60);
    const restMinutes = minutes % 60;
    if (hours && restMinutes) {
        return `${hours} ч ${restMinutes} м`;
    }
    if (hours) {
        return `${hours} ч`;
    }
    return `${restMinutes} м`;
}

function formatISOTimeToLocal(isoString) {
    if (!isoString) {
        return '';
    }
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) {
        return '';
    }
    return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
}

function escapeHtml(value) {
    if (typeof value !== 'string') {
        return '';
    }
    return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function getISODateString(isoString) {
    if (!isoString) {
        return null;
    }
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) {
        return null;
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

const ALLOWED_SHIFT_STATUSES = new Set(['planned', 'confirmed', 'active', 'completed']);

function extractShiftInterval(shift, slotStartMinutes, slotEndMinutes) {
    const startISO = shift.planned_start || shift.start_time;
    const endISO = shift.planned_end || shift.end_time;
    if (!startISO || !endISO) {
        return null;
    }
    const startDate = new Date(startISO);
    const endDate = new Date(endISO);
    if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
        return null;
    }
    const startMinutes = startDate.getHours() * 60 + startDate.getMinutes();
    const endMinutes = endDate.getHours() * 60 + endDate.getMinutes();
    if (endMinutes <= startMinutes) {
        return null;
    }
    const overlapStart = Math.max(slotStartMinutes, startMinutes);
    const overlapEnd = Math.min(slotEndMinutes, endMinutes);
    if (overlapEnd <= overlapStart) {
        return null;
    }
    return [overlapStart, overlapEnd];
}

function calculateFirstFreeInterval(timeslot, shifts) {
    const slotStartStr = timeslot.start_time || timeslot.start_time_str;
    const slotEndStr = timeslot.end_time || timeslot.end_time_str;
    const slotDateStr = timeslot.date || timeslot.slot_date || timeslot.start_date;
    
    const slotStartMinutes = timeStringToMinutes(slotStartStr);
    const slotEndMinutes = timeStringToMinutes(slotEndStr);
    
    if (
        !slotDateStr ||
        slotStartMinutes === null ||
        slotEndMinutes === null ||
        slotEndMinutes <= slotStartMinutes
    ) {
        return null;
    }
    
    const timeslotId = Number(timeslot.id);
    const busyIntervals = [];
    
    shifts.forEach(shift => {
        const status = (shift.status || '').toLowerCase();
        if (!ALLOWED_SHIFT_STATUSES.has(status)) {
            return;
        }
        
        const shiftTimeslotId = shift.time_slot_id !== undefined && shift.time_slot_id !== null
            ? Number(shift.time_slot_id)
            : null;
        
        const matchesTimeslot = !Number.isNaN(timeslotId) && shiftTimeslotId === timeslotId;
        const shiftDateStr = getISODateString(shift.planned_start || shift.start_time);
        const matchesDate = shiftDateStr === slotDateStr;
        const shouldApply = matchesTimeslot || (shiftTimeslotId === null && matchesDate);
        
        if (!shouldApply) {
            return;
        }
        
        const interval = extractShiftInterval(shift, slotStartMinutes, slotEndMinutes);
        if (interval) {
            busyIntervals.push(interval);
        }
    });
    
    if (busyIntervals.length === 0) {
        return {
            startMinutes: slotStartMinutes,
            endMinutes: slotEndMinutes,
            startStr: minutesToTime(slotStartMinutes),
            endStr: minutesToTime(slotEndMinutes),
            durationMinutes: slotEndMinutes - slotStartMinutes
        };
    }
    
    busyIntervals.sort((a, b) => a[0] - b[0]);
    const merged = [];
    busyIntervals.forEach(interval => {
        if (!merged.length) {
            merged.push(interval.slice());
            return;
        }
        const last = merged[merged.length - 1];
        if (interval[0] <= last[1]) {
            last[1] = Math.max(last[1], interval[1]);
        } else {
            merged.push(interval.slice());
        }
    });
    
    let cursor = slotStartMinutes;
    const freeSegments = [];
    
    merged.forEach(([start, end]) => {
        if (start > cursor) {
            freeSegments.push([cursor, start]);
        }
        cursor = Math.max(cursor, end);
    });
    
    if (cursor < slotEndMinutes) {
        freeSegments.push([cursor, slotEndMinutes]);
    }
    
    const firstSegment = freeSegments.find(segment => segment[1] - segment[0] > 0);
    if (!firstSegment) {
        return null;
    }
    
    const [freeStart, freeEnd] = firstSegment;
    return {
        startMinutes: freeStart,
        endMinutes: freeEnd,
        startStr: minutesToTime(freeStart),
        endStr: minutesToTime(freeEnd),
        durationMinutes: freeEnd - freeStart
    };
}

// Обновление календаря
function updateCalendar() {
    const monthNames = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                       'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
    
    document.getElementById('calendarMonthYear').textContent = `${monthNames[currentMonth]} ${currentYear}`;
    
    createPlanShiftCalendar();
}

// Создание календаря планирования
function createPlanShiftCalendar() {
    const calendarEl = document.getElementById('planShiftCalendar');
    const firstDay = new Date(currentYear, currentMonth, 1);
    const lastDay = new Date(currentYear, currentMonth + 1, 0);
    
    const firstMonday = new Date(firstDay);
    firstMonday.setDate(firstDay.getDate() - firstDay.getDay() + 1);
    
    const daysOfWeek = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
    
    let html = `
        <div class="calendar-weekdays">
            ${daysOfWeek.map(day => `<div class="calendar-weekday">${day}</div>`).join('')}
        </div>
        <div class="calendar-days">
    `;
    
    for (let i = 0; i < 35; i++) {
        const date = new Date(firstMonday);
        date.setDate(firstMonday.getDate() + i);
        
        const isCurrentMonth = date.getMonth() === currentMonth;
        const dateStr = formatDateForAPI(date);
        const timeslotsForDate = availableTimeslots.filter(ts => {
            const tsDate = ts.date || ts.slot_date || ts.start_date;
            return tsDate === dateStr;
        });
        const plannedShiftsForDate = employeePlannedShifts.filter(shift => shift.date === dateStr);
        
        let dayClass = 'calendar-day';
        if (!isCurrentMonth) {
            dayClass += ' disabled';
        } else if (timeslotsForDate.length > 0) {
            dayClass += ' has-timeslots';
        }
        
        html += `<div class="${dayClass}" data-date="${dateStr}">`;
        html += `<div class="day-number">${date.getDate()}</div>`;

        if (isCurrentMonth && plannedShiftsForDate.length > 0) {
            plannedShiftsForDate.forEach(shift => {
                const isSelected = selectedPlannedShiftIds.has(shift.schedule_id);
                const timeRange = shift.time_range || `${shift.start_time || '—'} - ${shift.end_time || '—'}`;
                const objectLine = shift.object_name ? `<div class="planned-shift-object">${escapeHtml(shift.object_name)}</div>` : '';
                
                html += `<div class="planned-shift ${isSelected ? 'selected' : ''}" data-schedule-id="${shift.schedule_id}">`;
                html += `<div class="shift-badge shift-badge-default">Запланировано</div>`;
                html += `<div class="planned-shift-time">${timeRange}</div>`;
                html += objectLine;
                html += '</div>';
            });
        }
        
        if (isCurrentMonth && timeslotsForDate.length > 0) {
            const displaySlots = timeslotsForDate.filter(ts => (ts.first_free_duration || 0) > 0);
            
            if (displaySlots.length > 0) {
                displaySlots.forEach(ts => {
                    const fullStart = ts.start_time || ts.start_time_str || '09:00';
                    const fullEnd = ts.end_time || ts.end_time_str || '21:00';
                    const freeStart = ts.first_free_start || fullStart;
                    const freeEnd = ts.first_free_end || fullEnd;
                    const fallbackDuration = Math.max(
                        0,
                        (timeStringToMinutes(fullEnd) || 0) - (timeStringToMinutes(fullStart) || 0)
                    );
                    const freeDurationLabel = formatFreeMinutes(ts.first_free_duration ?? fallbackDuration);
                    const slotKey = `${dateStr}_${ts.id}`;
                    const isSelected = selectedTimeslots.has(slotKey);
                    const statusLabel = ts.status === 'partially_filled' ? 'Частично свободен' : 'Свободен';
                    
                    html += `<div class="timeslot available ${isSelected ? 'selected' : ''}" data-timeslot-id="${ts.id}" data-free-start="${freeStart}" data-free-end="${freeEnd}">`;
                    html += `<div class="timeslot-time">${fullStart}-${fullEnd}</div>`;
                    html += `<div class="timeslot-slots">${statusLabel}: <strong>${freeStart}-${freeEnd}</strong></div>`;
                    html += `<div class="timeslot-slots">Доступно: ${freeDurationLabel}</div>`;
                    html += '</div>';
                });
            } else {
                html += '<div class="no-slots">Нет свободных окон</div>';
            }
        } else if (isCurrentMonth) {
            html += '<div class="empty-message">Нет тайм-слотов</div>';
        }
        
        html += '</div>';
    }
    
    html += '</div>';
    calendarEl.innerHTML = html;
    
    // Добавляем обработчики кликов
    calendarEl.removeEventListener('click', handleTimeslotClick);
    calendarEl.addEventListener('click', handleTimeslotClick);
    calendarEl.removeEventListener('click', handlePlannedShiftClick);
    calendarEl.addEventListener('click', handlePlannedShiftClick);
    
    updateSelectedSlotsInfo();
}

// Обработка клика по тайм-слоту
async function handleTimeslotClick(e) {
    const timeslot = e.target.closest('.timeslot');
    if (!timeslot || !timeslot.classList.contains('available')) {
        return;
    }
    
    const timeslotId = timeslot.dataset.timeslotId;
    const day = timeslot.closest('.calendar-day');
    const date = day.dataset.date;
    
    const employeeId = document.getElementById('planEmployeeSelect').value;
    if (!employeeId) {
        alert('Сначала выберите сотрудника');
        return;
    }
    
    const isAvailable = await checkEmployeeAvailability(employeeId, timeslotId);
    
    if (isAvailable) {
        const slotKey = `${date}_${timeslotId}`;
        
        if (selectedTimeslots.has(slotKey)) {
            selectedTimeslots.delete(slotKey);
            timeslot.classList.remove('selected');
        } else {
            selectedTimeslots.add(slotKey);
            timeslot.classList.add('selected');
        }
        setTimeout(() => updateSelectedSlotsInfo(), 100);
    }
}

function handlePlannedShiftClick(e) {
    const plannedShift = e.target.closest('.planned-shift');
    if (!plannedShift) {
        return;
    }
    
    e.preventDefault();
    
    const scheduleId = Number(plannedShift.dataset.scheduleId);
    if (Number.isNaN(scheduleId)) {
        return;
    }
    
    if (selectedPlannedShiftIds.has(scheduleId)) {
        selectedPlannedShiftIds.delete(scheduleId);
        plannedShift.classList.remove('selected');
    } else {
        selectedPlannedShiftIds.add(scheduleId);
        plannedShift.classList.add('selected');
    }
    
    updateSelectedSlotsInfo();
}

// Проверка доступности сотрудника
async function checkEmployeeAvailability(employeeId, timeslotId) {
    try {
        const response = await fetch('/owner/api/calendar/check-availability', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                timeslot_id: parseInt(timeslotId),
                employee_id: parseInt(employeeId)
            })
        });
        
        const result = await response.json();
        
        if (result.available) {
            return true;
        } else {
            let message = result.message || 'Сотрудник недоступен в это время';
            
            if (result.conflict_info) {
                const conflict = result.conflict_info;
                message = `Сотрудник в это время работает на объекте "${conflict.object_name}" с ${conflict.start_time} до ${conflict.end_time}`;
            }
            
            alert(message);
            return false;
        }
    } catch (error) {
        console.error('Ошибка проверки доступности:', error);
        alert('Ошибка проверки доступности сотрудника');
        return false;
    }
}

// Обновление информации о выбранных слотах
function updateSelectedSlotsInfo() {
    const infoEl = document.getElementById('selectedSlotsInfo');
    const timeslotsCountEl = document.getElementById('selectedTimeslotsCount');
    const plannedCountEl = document.getElementById('selectedPlannedCount');
    const cancelCountEl = document.getElementById('cancelPlannedCount');
    const cancelLineEl = document.getElementById('cancelInfoLine');
    const confirmBtn = document.getElementById('confirmPlanShift');
    
    if (!infoEl || !confirmBtn) {
        return;
    }
    
    const newTimeslotCount = selectedTimeslots.size;
    const selectedPlannedCount = selectedPlannedShiftIds.size;
    const initialPlannedCount = initialPlannedShiftIds.size;
    const cancelCount = Math.max(0, initialPlannedCount - selectedPlannedCount);
    
    if (timeslotsCountEl) {
        timeslotsCountEl.textContent = newTimeslotCount;
    }
    if (plannedCountEl) {
        plannedCountEl.textContent = selectedPlannedCount;
    }
    if (cancelCountEl) {
        cancelCountEl.textContent = cancelCount;
    }
    if (cancelLineEl) {
        if (cancelCount > 0) {
            cancelLineEl.classList.remove('text-muted');
            cancelLineEl.classList.add('text-warning');
        } else {
            cancelLineEl.classList.remove('text-warning');
            cancelLineEl.classList.add('text-muted');
        }
    }
    
    const shouldShow = newTimeslotCount > 0 || initialPlannedCount > 0 || selectedPlannedCount > 0 || cancelCount > 0;
    infoEl.style.display = shouldShow ? 'block' : 'none';
    
    const hasAction = newTimeslotCount > 0 || cancelCount > 0;
    confirmBtn.disabled = !hasAction;
}

// Подтверждение планирования смен
async function confirmPlanShift() {
    const objectId = document.getElementById('planObjectSelect').value;
    const employeeId = document.getElementById('planEmployeeSelect').value;
    
    if (!objectId || !employeeId) {
        alert('Выберите объект и сотрудника');
        return;
    }
    
    const timeslotsToPlan = Array.from(selectedTimeslots);
    const shiftsToCancel = Array.from(initialPlannedShiftIds).filter(id => !selectedPlannedShiftIds.has(id));
    
    if (timeslotsToPlan.length === 0 && shiftsToCancel.length === 0) {
        alert('Нет изменений для сохранения');
        return;
    }
    
    const confirmBtn = document.getElementById('confirmPlanShift');
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Обработка...';
    
    let planSuccess = 0;
    let planErrors = 0;
    let cancelSuccess = 0;
    let cancelErrors = 0;
    
    for (const scheduleId of shiftsToCancel) {
        try {
            const response = await fetch(`/owner/shifts_legacy/schedule_${scheduleId}/cancel`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            let result = null;
            try {
                result = await response.json();
            } catch (parseError) {
                result = null;
            }
            
            if (response.ok && result && result.success) {
                cancelSuccess++;
            } else {
                cancelErrors++;
                console.error('Ошибка отмены смены:', result?.message || response.statusText);
            }
        } catch (error) {
            cancelErrors++;
            console.error('Ошибка отмены смены:', error);
        }
    }
    
    for (const slotKey of timeslotsToPlan) {
        try {
            const [date, timeslotId] = slotKey.split('_');
            const timeslot = availableTimeslots.find(ts => ts.id == timeslotId);
            
            if (!timeslot) {
                planErrors++;
                console.error('Не найден тайм-слот для планирования', timeslotId);
                continue;
            }
            
            const freeStart = timeslot.first_free_start || timeslot.start_time || timeslot.start_time_str;
            const freeEnd = timeslot.first_free_end || timeslot.end_time || timeslot.end_time_str;
            
            if (!freeStart || !freeEnd) {
                planErrors++;
                console.error('Не удалось определить свободный интервал для тайм-слота', timeslotId);
                continue;
            }
            
            const response = await fetch('/owner/api/calendar/plan-shift', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    timeslot_id: parseInt(timeslotId),
                    employee_id: parseInt(employeeId),
                    start_time: freeStart,
                    end_time: freeEnd
                })
            });
            
            let result = null;
            try {
                result = await response.json();
            } catch (parseError) {
                result = null;
            }
            
            if (response.ok && result && result.success) {
                planSuccess++;
            } else {
                planErrors++;
                console.error('Ошибка планирования:', result?.message || response.statusText);
            }
        } catch (error) {
            planErrors++;
            console.error('Ошибка планирования смены:', error);
        }
    }
    
    confirmBtn.disabled = false;
    confirmBtn.innerHTML = '<i class="bi bi-calendar-check"></i> Запланировать смены';
    
    const summaryParts = [];
    if (planSuccess > 0) {
        summaryParts.push(`Запланировано смен: ${planSuccess}`);
    }
    if (cancelSuccess > 0) {
        summaryParts.push(`Отменено смен: ${cancelSuccess}`);
    }
    if (planErrors > 0) {
        summaryParts.push(`Ошибок планирования: ${planErrors}`);
    }
    if (cancelErrors > 0) {
        summaryParts.push(`Ошибок отмены: ${cancelErrors}`);
    }
    
    if (summaryParts.length > 0) {
        alert(summaryParts.join('\n'));
    } else {
        alert('Изменений не выполнено');
    }
    
    if ((planSuccess > 0 || cancelSuccess > 0) && returnToUrl) {
        window.location.href = returnToUrl;
    }
}
</script>
{% endblock %}

