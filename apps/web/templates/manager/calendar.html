{% extends "manager/base_manager.html" %}

{% block title %}{{ title }}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', path='css/shared/calendar.css') }}">
{% endblock %}

{% block manager_content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            {% include 'shared/calendar/objects_panel.html' %}
            {% include 'shared/calendar/employees_panel.html' %}
            {% include 'shared/calendar/quick_create_form.html' %}
            {% include 'shared/calendar/grid.html' %}
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', path='js/shared/calendar.js') }}"></script>
<script src="{{ url_for('static', path='js/shared/calendar_panels.js') }}"></script>
<script>
// Экспорт данных календаря для JS-логики занятости
window.calendar_weeks = {{ calendar_weeks | tojson }};

// Define callback functions before using them
function showShiftDetails(shiftId) {
    if (shiftId.toString().startsWith('schedule_')) {
        const scheduleId = shiftId.toString().replace('schedule_', '');
        window.location.href = `/manager/shifts/${scheduleId}?shift_type=schedule`;
    } else {
        window.location.href = `/manager/shifts/${shiftId}`;
    }
}

function showTimeslotDetails(timeslotId) {
    window.location.href = `/manager/timeslots/${timeslotId}`;
}

function showDateDetails(date) {}

const calendarManager = new CalendarManager({
    currentDate: new Date('{{ current_date }}'),
    viewType: '{{ view_type }}',
    baseUrl: '{{ request.url.path }}',
    onShiftClick: showShiftDetails,
    onTimeslotClick: showTimeslotDetails,
    onDateClick: showDateDetails
});
const calendarPanels = new CalendarPanels('manager');

calendarManager.assignEmployeeToTimeslot = async function(employeeId, timeslotId) {
    try {
        const employeeResponse = await fetch(`/manager/api/employees`);
        if (!employeeResponse.ok) throw new Error(`HTTP ${employeeResponse.status}`);
        const employees = await employeeResponse.json();
        const employee = employees.find(e => e.id == parseInt(employeeId));
        if (!employee) return calendarPanels.showNotification('Сотрудник не найден', 'error');

        const tsResp = await fetch(`/manager/calendar/api/timeslot/${timeslotId}`);
        if (!tsResp.ok) throw new Error(`HTTP ${tsResp.status}`);
        const timeslot = await tsResp.json();
        if (!timeslot || !timeslot.slot) return calendarPanels.showNotification('Тайм-слот не найден', 'error');
        const timeStr = `${timeslot.slot.start_time} - ${timeslot.slot.end_time}`;

        const planResp = await fetch('/manager/api/calendar/plan-shift', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ timeslot_id: Number(timeslotId), employee_id: Number(employeeId) })
        });
        const planData = await planResp.json().catch(() => ({}));
        if (!planResp.ok || planData.success === false) {
            const detail = planData && (planData.detail || planData.message);
            throw new Error(detail || `HTTP ${planResp.status}`);
        }
        calendarPanels.showNotification(`Сотрудник ${employee.name} назначен на тайм-слот ${timeStr}`, 'success');
        setTimeout(() => calendarManager.refresh(), 300);
    } catch (err) {
        console.error(err);
        calendarPanels.showNotification(`Ошибка назначения: ${err.message}`, 'error');
    }
};

calendarManager.createTimeslotFromObject = async function(objectId, date) {
    try {
        const objResp = await fetch(`/manager/calendar/api/objects`);
        const objects = await objResp.json();
        const object = objects.find(o => o.id == objectId);
        if (!object) return calendarPanels.showNotification('Объект не найден', 'error');
        await calendarPanels.showQuickCreateForm({
            id: objectId, name: object.name,
            hourlyRate: object.hourly_rate || 0,
            openingTime: object.opening_time || '09:00',
            closingTime: object.closing_time || '18:00'
        }, date);
    } catch (err) {
        console.error(err);
        calendarPanels.showNotification('Ошибка создания тайм-слота', 'error');
    }
};


document.addEventListener('DOMContentLoaded', function() {
    calendarPanels.init();
    setTimeout(() => { 
        calendarManager.setupDragDrop();
        // Initialize timeslot occupancy
        initializeTimeslotOccupancy();
    }, 1000);
});

// Initialize timeslot occupancy
function initializeTimeslotOccupancy() {
    // Собираем смены только из данных страницы, не из DOM
    const scheduledShifts = [];

    // Из window.calendar_weeks (если есть)
    if (window.calendar_weeks && Array.isArray(window.calendar_weeks)) {
        window.calendar_weeks.forEach(week => {
            week.forEach(day => {
                if (day && Array.isArray(day.shifts)) {
                    day.shifts.forEach(shift => {
                        if (shift && shift.time_slot_id && shift.status && shift.status !== 'cancelled') {
                            scheduledShifts.push({
                                id: shift.id,
                                time_slot_id: Number(shift.time_slot_id),
                                status: shift.status
                            });
                        }
                    });
                }
            });
        });
    }

    // Если смен нет в данных — подтягиваем с сервера статусы тайм-слотов как fallback
    const applyOccupancy = (shifts) => {
        // ПРАВИЛЬНАЯ ЛОГИКА: Группируем тайм-слоты по объектам и считаем смены для каждого
        const timeslotElements = document.querySelectorAll('.timeslot-item[data-timeslot-id]');
        const timeslotsByObject = {};

        // Группируем тайм-слоты по объектам
        timeslotElements.forEach(timeslot => {
            const timeslotId = parseInt(timeslot.dataset.timeslotId);
            const objectId = parseInt(timeslot.dataset.objectId);
            const maxEmployees = parseInt(timeslot.dataset.maxEmployees) || 1;

            if (!timeslotsByObject[objectId]) {
                timeslotsByObject[objectId] = [];
            }

            timeslotsByObject[objectId].push({
                element: timeslot,
                id: timeslotId,
                maxEmployees: maxEmployees
            });
        });

        // Для каждого объекта обрабатываем его тайм-слоты
        Object.keys(timeslotsByObject).forEach(objectId => {
            const objectTimeslots = timeslotsByObject[objectId];

            objectTimeslots.forEach(timeslot => {
                const timeslotId = timeslot.id;
                const maxEmployees = timeslot.maxEmployees;

                // Считаем смены ПРИВЯЗАННЫЕ к этому конкретному тайм-слоту (кроме cancelled)
                const shiftsForThisTimeslot = shifts.filter(shift =>
                    Number(shift.time_slot_id) === Number(timeslotId) && shift.status !== 'cancelled'
                );

                const currentShifts = shiftsForThisTimeslot.length;

                if (currentShifts >= maxEmployees) {
                    // Скрываем заполненные тайм-слоты
                    timeslot.element.style.display = 'none';
                } else {
                    // Показываем незаполненные тайм-слоты
                    timeslot.element.style.display = '';
                    const occupancyIndicator = timeslot.element.querySelector('.timeslot-occupancy');
                    if (occupancyIndicator) {
                        occupancyIndicator.querySelector('.occupancy-text').textContent = `${currentShifts}/${maxEmployees}`;
                        if (currentShifts === 0) {
                            occupancyIndicator.className = 'timeslot-occupancy available';
                        } else {
                            occupancyIndicator.className = 'timeslot-occupancy partial';
                        }
                    }
                }
            });
        });
    };

    if (scheduledShifts.length === 0) {
        const year = {{ year }};
        const month = {{ month }};
        fetch(`/manager/calendar/api/timeslots-status?year=${year}&month=${month}`)
            .then(r => r.json())
            .then(data => {
                // Преобразуем в вид со сдвигами на слот
                const shifts = [];
                (data || []).forEach(item => {
                    // planned shifts
                    (item.scheduled_shifts || []).forEach(s => {
                        if (s.status !== 'cancelled') {
                            shifts.push({ time_slot_id: item.slot_id, status: s.status });
                        }
                    });
                    // actual shifts
                    (item.actual_shifts || []).forEach(s => {
                        if (s.status !== 'cancelled') {
                            shifts.push({ time_slot_id: item.slot_id, status: s.status });
                        }
                    });
                });
                applyOccupancy(shifts);
            })
            .catch(() => applyOccupancy([]));
        return;
    }

    applyOccupancy(scheduledShifts);
}
</script>
{% endblock %}
