<!-- Shared Calendar Grid Component -->
<div class="calendar-wrapper">
    <!-- Фиксированная верхняя часть -->
    <div class="calendar-header-fixed">
        <div class="calendar-navigation">
            <div class="nav-group">
                <!-- Легенда слева -->
                <div class="legend-left">
                    <div class="calendar-legend" style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
            <div style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:14px; height:14px; border-radius:3px; background:#e3f2fd; border:1px solid #2196f3;"></span>
                <small>Запланированная смена</small>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
                            <span style="display:inline-block; width:14px; height:14px; border-radius:3px; background:#fff3e0; border:1px solid #ff9800;"></span>
                            <small>Активная смена</small>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:14px; height:14px; border-radius:3px; background:#c8e6c9; border:2px solid #2e7d32;"></span>
                <small>Завершённая смена</small>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
                            <span style="display:inline-block; width:14px; height:14px; border-radius:3px; background:#f3e5f5; border:1px solid #9c27b0;"></span>
                <small>Свободный тайм‑слот</small>
            </div>
        </div>
                </div>
                
                <!-- Переключатель месяцев в центре -->
                <div class="month-selector">
                    <div class="month-picker">
                        <div class="month-display" id="monthDisplay">
                            <span class="month-name" id="monthName">{{ calendar_title }}</span>
                            <i class="bi bi-chevron-down dropdown-icon"></i>
                        </div>
                        <div class="month-dropdown" id="monthDropdown">
                            <div class="dropdown-content">
                                <div class="year-selector">
                                    <button type="button" class="year-btn" onclick="changeYear(-1)">
                                        <i class="bi bi-chevron-left"></i>
                </button>
                                    <span class="year-display" id="yearDisplay">2025</span>
                                    <button type="button" class="year-btn" onclick="changeYear(1)">
                                        <i class="bi bi-chevron-right"></i>
                </button>
                                </div>
                                <div class="months-grid" id="monthsGrid">
                                    <div class="month-option" data-month="1">Янв</div>
                                    <div class="month-option" data-month="2">Фев</div>
                                    <div class="month-option" data-month="3">Мар</div>
                                    <div class="month-option" data-month="4">Апр</div>
                                    <div class="month-option" data-month="5">Май</div>
                                    <div class="month-option" data-month="6">Июн</div>
                                    <div class="month-option" data-month="7">Июл</div>
                                    <div class="month-option" data-month="8">Авг</div>
                                    <div class="month-option" data-month="9">Сен</div>
                                    <div class="month-option" data-month="10">Окт</div>
                                    <div class="month-option" data-month="11">Ноя</div>
                                    <div class="month-option" data-month="12">Дек</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="nav-actions">
                {% if objects and objects|length > 1 %}
                <div class="object-filter">
                    <div class="object-picker">
                        <div class="object-display" id="objectDisplay">
                            <span class="object-name" id="objectName">
                                {% if selected_object_id %}
                                    {% for obj in objects %}
                                        {% if obj.id == selected_object_id %}{{ obj.name }}{% endif %}
                                    {% endfor %}
                                {% else %}
                                    Все объекты
                                {% endif %}
                            </span>
                            <i class="bi bi-chevron-down dropdown-icon"></i>
                        </div>
                        <div class="object-dropdown" id="objectDropdown">
                            <div class="dropdown-content">
                                <div class="object-options">
                                    <div class="object-option" data-object-id="" data-object-name="Все объекты">
                                        <i class="bi bi-grid-3x3-gap"></i>
                                        <span>Все объекты</span>
                                    </div>
                                    {% for obj in objects %}
                                    <div class="object-option" data-object-id="{{ obj.id }}" data-object-name="{{ obj.name }}">
                                        <i class="bi bi-building"></i>
                                        <span>{{ obj.name }}</span>
                                    </div>
                                    {% endfor %}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                {% endif %}
                
                {% if show_today_button %}
                <button type="button" class="btn btn-primary btn-sm" onclick="goToToday()">
                    <i class="bi bi-calendar-today"></i> Сегодня
                </button>
                {% endif %}
        </div>
    </div>

        <!-- Заголовки дней недели (фиксированные) -->
        <div class="calendar-day-headers">
        <div class="calendar-day-header">Пн</div>
        <div class="calendar-day-header">Вт</div>
        <div class="calendar-day-header">Ср</div>
        <div class="calendar-day-header">Чт</div>
        <div class="calendar-day-header">Пт</div>
        <div class="calendar-day-header">Сб</div>
        <div class="calendar-day-header">Вс</div>
                                    </div>
                                </div>

    <!-- Скроллируемая часть с днями календаря -->
    <div class="calendar-scrollable">
        <div class="calendar-grid">
            <!-- Calendar days will be created by JavaScript -->
                </div>
    </div>
</div>


<!-- Calendar JavaScript -->
<script>
console.log('Shared calendar grid script loading...');

// Кэш для оптимизации производительности
const calendarCache = {
    dayElements: new Map(),
    lastUpdateTime: 0,
    updateThreshold: 100 // Минимальный интервал между обновлениями (мс)
};

// Calendar navigation
function navigateCalendar(direction) {
    const currentDate = new Date('{{ current_date }}');
    const newDate = new Date(currentDate);
    
    if (direction === 'prev') {
        newDate.setMonth(newDate.getMonth() - 1);
    } else {
        newDate.setMonth(newDate.getMonth() + 1);
    }
    
    // Reload calendar with new date
    loadCalendar(newDate);
}

function goToToday() {
    const today = new Date();
    loadCalendar(today);
    
    // Автопрокрутка к текущей дате после загрузки
    setTimeout(() => {
        scrollToCurrentDate();
    }, 200);
}

function filterByObject() {
    console.log('filterByObject called');
    const objectSelect = document.getElementById('objectFilter');
    console.log('objectSelect found:', !!objectSelect);
    
    const selectedObjectId = objectSelect ? objectSelect.value : '';
    console.log('selectedObjectId:', selectedObjectId);
    
    // Получаем текущие параметры из URL или создаем новые
    let currentSearch = window.location.search;
    console.log('current search string:', currentSearch);
    
    const params = new URLSearchParams(currentSearch);
    console.log('current params:', params.toString());
    
    if (selectedObjectId) {
        params.set('object_id', selectedObjectId);
    } else {
        params.delete('object_id');
    }
    
    const newSearch = params.toString();
    console.log('new params:', newSearch);
    
    // Формируем новый URL
    const newUrl = newSearch ? `${window.location.pathname}?${newSearch}` : window.location.pathname;
    console.log('new URL:', newUrl);
    
    window.location.href = newUrl;
}

// Universal Calendar Integration
function renderCalendarGrid(calendarData) {
    console.log('renderCalendarGrid called with data:', calendarData);
    
    if (!calendarData) {
        console.log('No calendar data provided');
        return;
    }
    
    try {
        console.log('About to call createCalendarGrid');
        // Создаем календарную сетку
        createCalendarGrid(calendarData);
        
        console.log('About to call updateCalendarStatistics');
        // Обновляем статистику
        updateCalendarStatistics(calendarData);
        
        console.log('About to call updateCalendarDisplay');
        // Обновляем отображение смен и тайм-слотов
        updateCalendarDisplay(calendarData);
        
        console.log('renderCalendarGrid completed');
    } catch (error) {
        console.error('Error in renderCalendarGrid:', error);
    }
}

function createCalendarGrid(calendarData) {
    console.log('createCalendarGrid called');
    
    const calendarGrid = document.querySelector('.calendar-grid');
    if (!calendarGrid) {
        console.error('Calendar grid not found');
        return;
    }
    
    // Удаляем существующие дни (оставляем только заголовки)
    const existingDays = calendarGrid.querySelectorAll('.calendar-day');
    existingDays.forEach(day => day.remove());
    
    // Получаем текущую дату из URL параметров или используем сегодняшнюю дату
    const urlParams = new URLSearchParams(window.location.search);
    const yearParam = urlParams.get('year');
    const monthParam = urlParams.get('month');
    
    const today = new Date();
    const year = yearParam ? parseInt(yearParam) : today.getFullYear();
    const month = monthParam ? parseInt(monthParam) - 1 : today.getMonth(); // monthParam 1-based, month 0-based
    
    // Создаем сетку для 13 месяцев: 6 до текущего + текущий + 6 после
    const months = [];
    const currentMonth = month + 1; // month 0-based, currentMonth 1-based
    
    for (let i = -6; i <= 6; i++) {
        const targetMonth = currentMonth + i;
        let targetYear = year;
        let monthNumber = targetMonth;
        
        // Корректируем год и месяц
        if (targetMonth <= 0) {
            monthNumber = 12 + targetMonth;
            targetYear = year - 1;
        } else if (targetMonth > 12) {
            monthNumber = targetMonth - 12;
            targetYear = year + 1;
        }
        
        months.push({ 
            year: targetYear, 
            month: monthNumber, 
            label: `month${i + 6}` 
        });
    }
    
    // Корректируем год для месяцев < 0 или > 11
    months.forEach(m => {
        if (m.month < 0) {
            m.month = 11;
            m.year--;
        } else if (m.month > 11) {
            m.month = 0;
            m.year++;
        }
    });
    
    // Находим понедельник первой недели ПЕРВОГО месяца (6 месяцев назад)
    const firstMonth = months[0]; // 6 месяцев назад
    const firstMonthFirstDay = new Date(firstMonth.year, firstMonth.month - 1, 1);
    const firstMonday = new Date(firstMonthFirstDay);
    firstMonday.setDate(firstMonthFirstDay.getDate() - firstMonthFirstDay.getDay() + 1);
    
    // Находим воскресенье последней недели последнего месяца (6 месяцев вперед)
    const lastMonth = months[12]; // 6 месяцев вперед
    const lastMonthLastDay = new Date(lastMonth.year, lastMonth.month, 0); // Последний день последнего месяца
    const lastSunday = new Date(lastMonthLastDay);
    lastSunday.setDate(lastMonthLastDay.getDate() + (6 - lastMonthLastDay.getDay()));
    
    // Создаем дни от первого понедельника до последнего воскресенья
    // Используем DocumentFragment для оптимизации DOM операций
    const fragment = document.createDocumentFragment();
    let workingDate = new Date(firstMonday);
    
    while (workingDate <= lastSunday) {
        const dateStr = workingDate.toISOString().split('T')[0];
        const dayNumber = workingDate.getDate();
        const workingMonth = workingDate.getMonth();
        const workingYear = workingDate.getFullYear();
        
        // Определяем, к какому месяцу относится день
        let isOtherMonth = true;
        months.forEach(monthData => {
            if (workingMonth === monthData.month && workingYear === monthData.year) {
                isOtherMonth = false;
            }
        });
        
        const isToday = dateStr === today.toISOString().split('T')[0];
        
        const dayElement = createDayElement(dateStr, dayNumber, isOtherMonth, isToday);
        fragment.appendChild(dayElement);
        
        workingDate.setDate(workingDate.getDate() + 1);
    }
    
    // Добавляем все дни одним операцией
    calendarGrid.appendChild(fragment);
    
    // Инициализируем drag&drop для календарных дней
    initializeDragAndDrop();
    
    // Автопрокрутка к текущей дате после создания сетки
    setTimeout(() => {
        scrollToCurrentDate();
    }, 100);
}

function createDayElement(dateStr, day, isOtherMonth, isToday) {
    const dayElement = document.createElement('div');
    dayElement.className = `calendar-day ${isOtherMonth ? 'other-month' : ''} ${isToday ? 'today' : ''}`;
    dayElement.setAttribute('data-date', dateStr);
    dayElement.setAttribute('data-day', day);
    
    // Добавляем сезонные классы
    const date = new Date(dateStr);
    const month = date.getMonth() + 1; // 1-12
    const monthName = getMonthName(month);
    const season = getSeason(month);
    
    dayElement.classList.add(season);
    dayElement.classList.add(monthName.toLowerCase());
    
    dayElement.innerHTML = `
        <div class="day-number">${day}</div>
        <div class="day-content"></div>
    `;
    
    // Добавляем анимацию появления
    dayElement.classList.add('day-appear');
    
    return dayElement;
}

// Функция для получения названия месяца
function getMonthName(month) {
    const monthNames = [
        'january', 'february', 'march', 'april', 'may', 'june',
        'july', 'august', 'september', 'october', 'november', 'december'
    ];
    return monthNames[month - 1];
}

// Функция для определения сезона
function getSeason(month) {
    if (month === 12 || month === 1 || month === 2) {
        return 'winter';
    } else if (month >= 3 && month <= 5) {
        return 'spring';
    } else if (month >= 6 && month <= 8) {
        return 'summer';
    } else {
        return 'autumn';
    }
}

function updateCalendarStatistics(calendarData) {
    console.log('updateCalendarStatistics called');
    try {
        // Обновляем статистику в шапке календаря
        const statsElement = document.getElementById('calendar-stats');
        console.log('statsElement found:', statsElement);
        if (statsElement && calendarData.stats) {
            console.log('Updating stats with data:', calendarData.stats);
            statsElement.innerHTML = `
                <div class="stat-item">
                    <span class="stat-label">Тайм-слоты:</span>
                    <span class="stat-value">${calendarData.stats.total_timeslots || calendarData.total_timeslots || 0}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Смены:</span>
                    <span class="stat-value">${calendarData.stats.total_shifts || calendarData.total_shifts || 0}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Запланировано:</span>
                    <span class="stat-value">${calendarData.stats.planned_shifts || 0}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Активные:</span>
                    <span class="stat-value">${calendarData.stats.active_shifts || 0}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Завершено:</span>
                    <span class="stat-value">${calendarData.stats.completed_shifts || 0}</span>
                </div>
            `;
        } else {
            console.log('No stats element or stats data');
        }
        console.log('updateCalendarStatistics completed successfully');
    } catch (error) {
        console.error('Error in updateCalendarStatistics:', error);
    }
}

function updateCalendarDisplay(calendarData) {
    console.log('updateCalendarDisplay called - START');
    console.log('calendarData:', calendarData);
    console.log('calendarData type:', typeof calendarData);
    try {
        console.log('Updating calendar display with:', calendarData);
        console.log('timeslotsByDate keys:', Object.keys(calendarData.timeslotsByDate || {}));
        console.log('shiftsByDate keys:', Object.keys(calendarData.shiftsByDate || {}));
        
        // Умная виртуализация: обновляем видимые дни + текущую неделю
        const scrollableContainer = document.querySelector('.calendar-scrollable');
        if (!scrollableContainer) {
            // Fallback: обновляем все дни
            const allDayElements = document.querySelectorAll('.calendar-day[data-date]');
            console.log(`Fallback: Found ${allDayElements.length} day elements to update`);
            allDayElements.forEach(dayElement => {
                const date = dayElement.dataset.date;
                updateDayDisplay(dayElement, date, calendarData);
            });
            return;
        }
        
        const containerRect = scrollableContainer.getBoundingClientRect();
        const visibleTop = scrollableContainer.scrollTop;
        const visibleBottom = visibleTop + containerRect.height;
        
        // Находим видимые дни
        const allDayElements = document.querySelectorAll('.calendar-day[data-date]');
        let visibleElements = [];
        let currentWeekElements = [];
        
        // Получаем текущую дату для определения текущей недели
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0];
        
        allDayElements.forEach(dayElement => {
            const dayRect = dayElement.getBoundingClientRect();
            const dayTop = dayRect.top - containerRect.top + scrollableContainer.scrollTop;
            const dayBottom = dayTop + dayRect.height;
            const date = dayElement.dataset.date;
            
            // Проверяем, пересекается ли день с видимой областью
            if (dayBottom >= visibleTop && dayTop <= visibleBottom) {
                visibleElements.push(dayElement);
            }
            
            // Проверяем, относится ли день к текущей неделе
            const dayDate = new Date(date);
            const todayDate = new Date(todayStr);
            const daysDiff = Math.abs((dayDate - todayDate) / (1000 * 60 * 60 * 24));
            if (daysDiff <= 7) { // В пределах недели
                currentWeekElements.push(dayElement);
            }
        });
        
        // Объединяем видимые дни и дни текущей недели
        const elementsToUpdate = new Set([...visibleElements, ...currentWeekElements]);
        
        // Обновляем объединенный набор дней
        console.log(`Smart virtualization: Found ${elementsToUpdate.size}/${allDayElements.length} elements to update (${visibleElements.length} visible + ${currentWeekElements.length} current week)`);
        elementsToUpdate.forEach(dayElement => {
            const date = dayElement.dataset.date;
            updateDayDisplay(dayElement, date, calendarData);
        });
        
        console.log('updateCalendarDisplay completed successfully');
    } catch (error) {
        console.error('Error in updateCalendarDisplay:', error);
    }
}

function updateDayDisplay(dayElement, date, calendarData) {
    // Временно отключаем кэширование для отладки
    // const cacheKey = `${date}-${dayElement.dataset.lastUpdate || 0}`;
    // const now = Date.now();
    
    // if (calendarCache.dayElements.has(cacheKey) && 
    //     (now - calendarCache.lastUpdateTime) < calendarCache.updateThreshold) {
    //     return; // Пропускаем обновление, если данные не изменились
    // }
    
    console.log(`Updating day display for ${date}`);
    const dayContent = dayElement.querySelector('.day-content');
    console.log(`Day content element:`, dayContent);
    if (!dayContent) {
        console.log(`No day-content found for date ${date}`);
        return;
    }
    
    // Очищаем существующий контент
    dayContent.innerHTML = '';
    console.log(`Cleared day content for ${date}`);
    
    // Получаем данные для дня
    const timeslots = calendarData.timeslotsByDate[date] || [];
    const shifts = calendarData.shiftsByDate[date] || [];
    
    console.log(`Found ${timeslots.length} timeslots and ${shifts.length} shifts for ${date}`);
    console.log(`timeslotsByDate keys:`, Object.keys(calendarData.timeslotsByDate || {}));
    console.log(`shiftsByDate keys:`, Object.keys(calendarData.shiftsByDate || {}));
    
    // Проверяем, есть ли данные для дня
    const hasTimeslots = timeslots.length > 0;
    const hasShifts = shifts.length > 0;
    
    if (!hasTimeslots && !hasShifts) {
        // Показываем сообщение "Нет тайм-слотов!"
        const noDataElement = document.createElement('div');
        noDataElement.className = 'no-data-message';
        noDataElement.innerHTML = '<small class="text-muted">Нет тайм-слотов!</small>';
        dayContent.appendChild(noDataElement);
        console.log(`Added no-data message for ${date}`);
        return;
    }
    
    // Добавляем тайм-слоты
    console.log(`Adding ${timeslots.length} timeslots for ${date}`);
    timeslots.forEach(timeslot => {
        const timeslotElement = createTimeslotElement(timeslot);
        if (timeslotElement) {  // Проверяем, что элемент не null (не полностью занятый тайм-слот)
            dayContent.appendChild(timeslotElement);
            console.log(`Added timeslot ${timeslot.id} to ${date}`);
        } else {
            console.log(`Skipped fully occupied timeslot ${timeslot.id} for ${date}`);
        }
    });
    
    // Добавляем смены
    console.log(`Adding ${shifts.length} shifts for ${date}`);
    shifts.forEach(shift => {
        const shiftElement = createShiftElement(shift);
        if (shiftElement) {  // Проверяем, что элемент не null (не отмененная смена)
            dayContent.appendChild(shiftElement);
            console.log(`Added shift ${shift.id} to ${date}`);
        } else {
            console.log(`Skipped cancelled shift ${shift.id} for ${date}`);
        }
    });
    
    // Временно отключаем обновление кэша для отладки
    // calendarCache.dayElements.set(cacheKey, true);
    // calendarCache.lastUpdateTime = now;
    // dayElement.dataset.lastUpdate = now;
}

function createTimeslotElement(timeslot) {
    // Определяем занятость тайм-слота
    const currentEmployees = timeslot.current_employees || 0;
    const maxEmployees = timeslot.max_employees || 1;
    
    // Не отображаем полностью занятые тайм-слоты
    if (currentEmployees >= maxEmployees) {
        console.log(`Skipping fully occupied timeslot ${timeslot.id} (${currentEmployees}/${maxEmployees})`);
        return null;
    }
    
    const div = document.createElement('div');
    div.className = 'timeslot-item timeslot-free';
    div.setAttribute('data-timeslot-id', timeslot.id);
    div.setAttribute('data-timeslot-date', timeslot.date);
    div.setAttribute('data-timeslot-start-time', timeslot.start_time);
    div.setAttribute('data-timeslot-end-time', timeslot.end_time);
    div.setAttribute('data-timeslot-object-id', timeslot.object_id);
    div.onclick = () => showTimeslotDetails(timeslot.id);
    
    const occupancyBadge = `<div class="timeslot-badge">${currentEmployees}/${maxEmployees}</div>`;
    
    div.innerHTML = `
        <div class="timeslot-time">${timeslot.start_time} - ${timeslot.end_time}</div>
        <div class="timeslot-object">${timeslot.object_name}</div>
        <div class="timeslot-rate">${timeslot.hourly_rate}₽/ч</div>
        ${occupancyBadge}
    `;
    
    return div;
}

function createShiftElement(shift) {
    // Не отображаем отмененные смены
    if (shift.status === 'cancelled') {
        console.log(`Skipping cancelled shift ${shift.id}`);
        return null;
    }
    
    const div = document.createElement('div');
    div.className = `shift-item shift-${shift.shift_type}`;
    div.setAttribute('data-shift-id', shift.id);
    div.onclick = () => showShiftDetails(shift.id);
    
    // Определяем время начала и окончания
    let startTime = '';
    let endTime = '';
    
    if (shift.shift_type === 'planned') {
        // Для запланированных смен используем planned_start и planned_end
        startTime = shift.planned_start ? shift.planned_start.split('T')[1].substring(0, 5) : '';
        endTime = shift.planned_end ? shift.planned_end.split('T')[1].substring(0, 5) : '';
    } else {
        // Для активных/завершенных смен используем start_time и end_time
        startTime = shift.start_time ? shift.start_time.split('T')[1].substring(0, 5) : '';
        endTime = shift.end_time ? shift.end_time.split('T')[1].substring(0, 5) : '';
    }
    
    // Добавляем стикер для запланированных смен
    const sticker = shift.shift_type === 'planned' ? '<div class="shift-sticker">1/1</div>' : '';
    
    div.innerHTML = `
        <div class="shift-time">${startTime} - ${endTime}</div>
        <div class="shift-employee">${shift.user_name}</div>
        <div class="shift-object">${shift.object_name}</div>
        ${sticker}
    `;
    
    return div;
}

// Делаем функцию доступной глобально
window.renderCalendarGrid = renderCalendarGrid;

// Month Selector JavaScript
let currentYear = new Date().getFullYear();
let currentMonth = new Date().getMonth() + 1;
let isUserScrolling = false; // Флаг для отслеживания пользовательской прокрутки

// Оптимизированная логика определения месяца
function determineCurrentMonth() {
    // ПРИОРИТЕТ 1: Если пользователь выбрал месяц вручную
    if (window.userSelectedMonth) {
        return window.userSelectedMonth;
    }
    
    // ПРИОРИТЕТ 2: URL параметры (если есть)
    const urlParams = new URLSearchParams(window.location.search);
    const yearParam = urlParams.get('year');
    const monthParam = urlParams.get('month');
    
    if (yearParam && monthParam) {
        const urlMonth = parseInt(monthParam);
        return { year: parseInt(yearParam), month: urlMonth };
    }
    
    // ПРИОРИТЕТ 3: Определение по видимой области календаря
    const visibleMonth = getVisibleMonthFromScroll();
    if (visibleMonth) {
        return visibleMonth;
    }
    
    // ПРИОРИТЕТ 4: Текущая дата
    const today = new Date();
    return { year: today.getFullYear(), month: today.getMonth() + 1 };
}

// Определение видимого месяца по прокрутке
function getVisibleMonthFromScroll() {
    const scrollableContainer = document.querySelector('.calendar-scrollable');
    if (!scrollableContainer) return null;
    
    const containerRect = scrollableContainer.getBoundingClientRect();
    const containerCenter = containerRect.top + (containerRect.height / 2);
    
    // Находим все дни календаря
    const dayElements = document.querySelectorAll('.calendar-day[data-date]');
    let closestDay = null;
    let minDistance = Infinity;
    
    // Ищем день, ближайший к центру контейнера
    dayElements.forEach(dayElement => {
        const dayRect = dayElement.getBoundingClientRect();
        const dayCenter = dayRect.top + (dayRect.height / 2);
        const distance = Math.abs(dayCenter - containerCenter);
        
        if (distance < minDistance) {
            minDistance = distance;
            closestDay = dayElement;
        }
    });
    
    if (closestDay) {
        const dateStr = closestDay.dataset.date;
        const date = new Date(dateStr);
        return { year: date.getFullYear(), month: date.getMonth() + 1 };
    }
    
    return null;
}

// Инициализация переключателя месяцев
function initMonthSelector() {
    const monthDisplay = document.getElementById('monthDisplay');
    const monthDropdown = document.getElementById('monthDropdown');
    const yearDisplay = document.getElementById('yearDisplay');
    const monthOptions = document.querySelectorAll('.month-option');
    
    // Определяем текущий месяц по оптимизированной логике
    const monthInfo = determineCurrentMonth();
    currentYear = monthInfo.year;
    currentMonth = monthInfo.month;
    
    
    // Обновляем отображение
    updateMonthDisplay();
    
    // Обработчики событий
    monthDisplay.addEventListener('click', toggleMonthDropdown);
    
    // Закрытие при клике вне элемента
    document.addEventListener('click', (e) => {
        if (!monthDisplay.contains(e.target) && !monthDropdown.contains(e.target)) {
            closeMonthDropdown();
        }
    });
    
    // Обработчики для месяцев
    monthOptions.forEach(option => {
        option.addEventListener('click', () => {
            const month = parseInt(option.dataset.month);
            selectMonth(month);
        });
    });
}

function toggleMonthDropdown() {
    const monthDisplay = document.getElementById('monthDisplay');
    const monthDropdown = document.getElementById('monthDropdown');
    
    monthDisplay.classList.toggle('active');
    monthDropdown.classList.toggle('show');
    
    if (monthDropdown.classList.contains('show')) {
        updateMonthOptions();
    }
}

function closeMonthDropdown() {
    const monthDisplay = document.getElementById('monthDisplay');
    const monthDropdown = document.getElementById('monthDropdown');
    
    monthDisplay.classList.remove('active');
    monthDropdown.classList.remove('show');
}

function updateMonthDisplay() {
    const monthName = document.getElementById('monthName');
    const yearDisplay = document.getElementById('yearDisplay');
    
    const monthNames = [
        'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
        'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
    ];
    
    // currentMonth уже 1-based (1-12), поэтому используем currentMonth - 1 для массива
    monthName.textContent = `${monthNames[currentMonth - 1]} ${currentYear}`;
    yearDisplay.textContent = currentYear;
}

function updateMonthOptions() {
    const monthOptions = document.querySelectorAll('.month-option');
    
    monthOptions.forEach(option => {
        const month = parseInt(option.dataset.month);
        option.classList.toggle('active', month === currentMonth);
    });
}

function changeYear(delta) {
    currentYear += delta;
    updateMonthDisplay();
    updateMonthOptions();
}

function selectMonth(month) {
    // Устанавливаем флаг пользовательского выбора
    window.userSelectedMonth = { year: currentYear, month: month };
    
    currentMonth = month;
    closeMonthDropdown();
    updateMonthDisplay();
    updateMonthOptions();
    
    // Используем новый метод динамической загрузки
    if (window.universalCalendar && typeof window.universalCalendar.selectMonth === 'function') {
        window.universalCalendar.selectMonth(currentYear, currentMonth);
    } else {
        // Fallback к старому методу
        const newDate = new Date(currentYear, currentMonth - 1, 1);
        loadCalendar(newDate);
        
        setTimeout(() => {
            scrollToSelectedMonth();
            setTimeout(() => {
                window.userSelectedMonth = null;
            }, 1000);
        }, 200);
    }
}

// Автопрокрутка к текущей дате
function scrollToCurrentDate() {
    const scrollableContainer = document.querySelector('.calendar-scrollable');
    if (!scrollableContainer) return;
    
    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];
    
    // Находим элемент с текущей датой
    const todayElement = document.querySelector(`.calendar-day[data-date="${todayStr}"]`);
    if (!todayElement) {
        return;
    }
    
    // Получаем позицию элемента относительно контейнера
    const containerRect = scrollableContainer.getBoundingClientRect();
    const elementRect = todayElement.getBoundingClientRect();
    
    // Вычисляем позицию для прокрутки (центрируем элемент)
    const elementTop = elementRect.top - containerRect.top + scrollableContainer.scrollTop;
    const containerHeight = scrollableContainer.clientHeight;
    const elementHeight = elementRect.height;
    
    // Прокручиваем так, чтобы элемент был в центре видимой области
    const scrollTo = elementTop - (containerHeight / 2) + (elementHeight / 2);
    
    // Плавная прокрутка
    scrollableContainer.scrollTo({
        top: Math.max(0, scrollTo),
        behavior: 'smooth'
    });
}

// Автопрокрутка к выбранному месяцу
function scrollToSelectedMonth() {
    const scrollableContainer = document.querySelector('.calendar-scrollable');
    if (!scrollableContainer) return;
    
    // Находим первый день выбранного месяца
    const selectedMonthFirstDay = new Date(currentYear, currentMonth - 1, 1);
    const selectedMonthStr = selectedMonthFirstDay.toISOString().split('T')[0];
    
    // Находим элемент с первым днем выбранного месяца
    const monthElement = document.querySelector(`.calendar-day[data-date="${selectedMonthStr}"]`);
    if (!monthElement) {
        return;
    }
    
    // Получаем позицию элемента относительно контейнера
    const containerRect = scrollableContainer.getBoundingClientRect();
    const elementRect = monthElement.getBoundingClientRect();
    
    // Вычисляем позицию для прокрутки (показываем элемент в верхней части)
    const elementTop = elementRect.top - containerRect.top + scrollableContainer.scrollTop;
    
    // Плавная прокрутка к началу выбранного месяца
    scrollableContainer.scrollTo({
        top: Math.max(0, elementTop - 20), // Небольшой отступ сверху
        behavior: 'smooth'
    });
}

// Безопасная инициализация календаря
function safeInitCalendar() {
    try {
        initMonthSelector();
        initScrollTracking();
    } catch (error) {
        console.error('Calendar initialization error:', error);
        // Fallback к базовой функциональности
        setTimeout(() => {
            try {
                initMonthSelector();
                initScrollTracking();
            } catch (retryError) {
                console.error('Calendar retry initialization failed:', retryError);
            }
        }, 1000);
    }
}

// Object Filter JavaScript
let currentObjectId = null;

// Инициализация фильтра объектов
function initObjectFilter() {
    const objectDisplay = document.getElementById('objectDisplay');
    const objectDropdown = document.getElementById('objectDropdown');
    const objectOptions = document.querySelectorAll('.object-option');
    
    if (!objectDisplay || !objectDropdown) return;
    
    // Получаем текущий объект из URL
    const urlParams = new URLSearchParams(window.location.search);
    const objectIdParam = urlParams.get('object_id');
    currentObjectId = objectIdParam ? parseInt(objectIdParam) : null;
    
    // Обновляем отображение
    updateObjectDisplay();
    
    // Обработчики событий
    objectDisplay.addEventListener('click', toggleObjectDropdown);
    
    // Закрытие при клике вне элемента
    document.addEventListener('click', (e) => {
        if (!objectDisplay.contains(e.target) && !objectDropdown.contains(e.target)) {
            closeObjectDropdown();
        }
    });
    
    // Обработчики для объектов
    objectOptions.forEach(option => {
        option.addEventListener('click', () => {
            const objectId = option.dataset.objectId ? parseInt(option.dataset.objectId) : null;
            const objectName = option.dataset.objectName;
            selectObject(objectId, objectName);
        });
    });
}

function toggleObjectDropdown() {
    const objectDisplay = document.getElementById('objectDisplay');
    const objectDropdown = document.getElementById('objectDropdown');
    
    objectDisplay.classList.toggle('active');
    objectDropdown.classList.toggle('show');
    
    if (objectDropdown.classList.contains('show')) {
        updateObjectOptions();
    }
}

function closeObjectDropdown() {
    const objectDisplay = document.getElementById('objectDisplay');
    const objectDropdown = document.getElementById('objectDropdown');
    
    objectDisplay.classList.remove('active');
    objectDropdown.classList.remove('show');
}

function updateObjectDisplay() {
    const objectName = document.getElementById('objectName');
    const objectOptions = document.querySelectorAll('.object-option');
    
    // Находим название текущего объекта
    let displayName = 'Все объекты';
    objectOptions.forEach(option => {
        const optionId = option.dataset.objectId ? parseInt(option.dataset.objectId) : null;
        if (optionId === currentObjectId) {
            displayName = option.dataset.objectName;
        }
    });
    
    objectName.textContent = displayName;
}

function updateObjectOptions() {
    const objectOptions = document.querySelectorAll('.object-option');
    
    objectOptions.forEach(option => {
        const optionId = option.dataset.objectId ? parseInt(option.dataset.objectId) : null;
        option.classList.toggle('active', optionId === currentObjectId);
    });
}

function selectObject(objectId, objectName) {
    currentObjectId = objectId;
    closeObjectDropdown();
    updateObjectDisplay();
    updateObjectOptions();
    
    // Применяем фильтр
    applyObjectFilter();
}

function applyObjectFilter() {
    const params = new URLSearchParams(window.location.search);
    
    if (currentObjectId) {
        params.set('object_id', currentObjectId);
    } else {
        params.delete('object_id');
    }
    
    // Перезагружаем страницу с новым фильтром
    window.location.href = window.location.pathname + '?' + params.toString();
}

// Инициализация при загрузке DOM
document.addEventListener('DOMContentLoaded', function() {
    safeInitCalendar();
    initObjectFilter();
});

// Отслеживание прокрутки для обновления переключателя месяцев
function initScrollTracking() {
    const scrollableContainer = document.querySelector('.calendar-scrollable');
    if (!scrollableContainer) return;
    
    let scrollTimeout;
    let isScrolling = false;
    
    // Оптимизированный обработчик прокрутки с дебаунсингом
    scrollableContainer.addEventListener('scroll', function() {
        if (!isScrolling) {
            isScrolling = true;
            requestAnimationFrame(() => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateMonthDisplayFromScroll();
                    isScrolling = false;
                }, 100); // Уменьшена задержка для лучшей отзывчивости
            });
        }
    }, { passive: true });
}

function updateMonthDisplayFromScroll() {
    // Не обновляем, если пользователь недавно выбрал месяц вручную
    if (window.userSelectedMonth) {
        return;
    }
    
    const visibleMonth = getVisibleMonthFromScroll();
    if (visibleMonth && (visibleMonth.year !== currentYear || visibleMonth.month !== currentMonth)) {
        currentYear = visibleMonth.year;
        currentMonth = visibleMonth.month;
        updateMonthDisplay();
        updateMonthOptions();
    }
}

// Проверяем что функция доступна после загрузки и привязываем события
document.addEventListener('DOMContentLoaded', function() {
    
    // Привязываем событие к фильтру объектов
    const objectFilter = document.getElementById('objectFilter');
    if (objectFilter) {
        objectFilter.addEventListener('change', function() {
            if (typeof window.filterByObject === 'function') {
                window.filterByObject();
            }
        });
    }
});

function loadCalendar(date) {
    const params = new URLSearchParams(window.location.search);
    params.set('year', date.getFullYear());
    params.set('month', date.getMonth() + 1);
    
    // Сохраняем фильтр объекта при навигации
    const objectSelect = document.getElementById('objectFilter');
    if (objectSelect && objectSelect.value) {
        params.set('object_id', objectSelect.value);
    }
    
    window.location.search = params.toString();
}

// Shift and timeslot details
function showShiftDetails(shiftId) {
    console.log('Shift clicked:', shiftId);
    if (shiftId.toString().startsWith('schedule_')) {
        const scheduleId = shiftId.toString().replace('schedule_', '');
        window.location.href = `/manager/shifts/${scheduleId}?shift_type=schedule`;
    } else {
        window.location.href = `/manager/shifts/${shiftId}`;
    }
}

function showTimeslotDetails(timeslotId) {
    console.log('Timeslot clicked:', timeslotId);
    window.location.href = `/manager/timeslots/${timeslotId}`;
}

// Инициализация drag&drop для календарных дней и тайм-слотов
function initializeDragAndDrop() {
    console.log('Initializing drag&drop for calendar days and timeslots');
    
    // Обработчики для календарных дней
    document.addEventListener('dragover', function(e) {
        e.preventDefault();
        const dayElement = e.target.closest('.calendar-day');
        const timeslotElement = e.target.closest('.timeslot-item, .calendar-timeslot');
        
        if (dayElement) {
            dayElement.classList.add('drag-over');
        }
        if (timeslotElement) {
            timeslotElement.classList.add('drag-over');
        }
    });
    
    document.addEventListener('dragleave', function(e) {
        const dayElement = e.target.closest('.calendar-day');
        const timeslotElement = e.target.closest('.timeslot-item, .calendar-timeslot');
        
        if (dayElement) {
            dayElement.classList.remove('drag-over');
        }
        if (timeslotElement) {
            timeslotElement.classList.remove('drag-over');
        }
    });
    
    document.addEventListener('drop', function(e) {
        e.preventDefault();
        const dayElement = e.target.closest('.calendar-day');
        const timeslotElement = e.target.closest('.timeslot-item, .calendar-timeslot');
        
        if (timeslotElement) {
            // Приоритет: тайм-слот
            timeslotElement.classList.remove('drag-over');
            const data = e.dataTransfer.getData('text/plain');
            if (data.startsWith('employee:')) {
                const employeeId = data.replace('employee:', '');
                handleEmployeeDropOnTimeslot(timeslotElement, employeeId);
            }
        } else if (dayElement) {
            // Fallback: день календаря
            dayElement.classList.remove('drag-over');
            const data = e.dataTransfer.getData('text/plain');
            if (data.startsWith('object:')) {
                const objectId = data.replace('object:', '');
                handleObjectDropOnDay(dayElement, objectId);
            } else if (data.startsWith('employee:')) {
                const employeeId = data.replace('employee:', '');
                handleEmployeeDropOnDay(dayElement, employeeId);
            }
        }
    });
}

// Обработка перетаскивания объекта на день
function handleObjectDropOnDay(dayElement, objectId) {
    const date = dayElement.dataset.date;
    console.log(`Object ${objectId} dropped on day ${date}`);
    
    // Открываем форму быстрого создания с предзаполненными данными
    if (window.calendarPanels && window.calendarPanels.showQuickCreateForm) {
        // Найдем данные объекта
        const objectItem = document.querySelector(`[data-object-id="${objectId}"]`);
        if (objectItem) {
            const object = {
                id: objectId,
                name: objectItem.dataset.objectName,
                hourlyRate: objectItem.dataset.hourlyRate,
                openingTime: objectItem.dataset.openingTime,
                closingTime: objectItem.dataset.closingTime
            };
            window.calendarPanels.showQuickCreateForm(object, date);
        }
    }
}

// Обработка перетаскивания сотрудника на тайм-слот
function handleEmployeeDropOnTimeslot(timeslotElement, employeeId) {
    console.log(`Employee ${employeeId} dropped on timeslot`);
    
    // Получаем данные тайм-слота
    const timeslotId = timeslotElement.dataset.timeslotId;
    const timeslotDate = timeslotElement.dataset.timeslotDate;
    const timeslotStartTime = timeslotElement.dataset.timeslotStartTime;
    const timeslotEndTime = timeslotElement.dataset.timeslotEndTime;
    const timeslotObjectId = timeslotElement.dataset.timeslotObjectId;
    
    console.log('Timeslot data:', {
        id: timeslotId,
        date: timeslotDate,
        startTime: timeslotStartTime,
        endTime: timeslotEndTime,
        objectId: timeslotObjectId
    });
    
    // Найдем данные сотрудника
    const employeeItem = document.querySelector(`[data-employee-id="${employeeId}"]`);
    console.log('Found employee item:', employeeItem);
    
    if (employeeItem && timeslotId) {
        const employee = {
            id: employeeId,
            name: employeeItem.dataset.employeeName,
            role: employeeItem.dataset.employeeRole,
            status: employeeItem.dataset.employeeStatus
        };
        
        console.log('Employee data:', employee);
        
        // Создаем запланированную смену
        createPlannedShift({
            employeeId: employeeId,
            employeeName: employee.name,
            timeslotId: timeslotId,
            timeslotDate: timeslotDate,
            timeslotStartTime: timeslotStartTime,
            timeslotEndTime: timeslotEndTime,
            timeslotObjectId: timeslotObjectId
        });
    } else {
        console.error('Missing data:', {
            employeeItem: !!employeeItem,
            timeslotId: !!timeslotId
        });
        
        if (window.calendarPanels && window.calendarPanels.showNotification) {
            window.calendarPanels.showNotification(
                `Ошибка: не удалось создать смену. Проверьте данные тайм-слота и сотрудника.`, 
                'error'
            );
        }
    }
}

// Создание запланированной смены
let isCreatingShift = false; // Флаг для предотвращения двойного выполнения

async function createPlannedShift(data) {
    if (isCreatingShift) {
        console.log('Shift creation already in progress, skipping...');
        return;
    }
    
    isCreatingShift = true;
    console.log('Creating planned shift with data:', data);
    
    try {
        const response = await fetch('/manager/api/calendar/plan-shift', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                timeslot_id: parseInt(data.timeslotId),
                employee_id: parseInt(data.employeeId)
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('Planned shift created:', result);
            
            if (window.calendarPanels && window.calendarPanels.showNotification) {
                window.calendarPanels.showNotification(
                    `Запланированная смена создана для ${data.employeeName} на ${data.timeslotDate}`, 
                    'success'
                );
            }
            
            // Обновляем календарь
            setTimeout(() => {
                location.reload();
            }, 1000);
        } else {
            console.error('Error creating planned shift:', result);
            
            // Показываем конкретное сообщение об ошибке
            let errorMessage = result.message || 'Ошибка планирования смены';
            if (result.detail) {
                errorMessage = result.detail;
            }
            
            if (window.calendarPanels && window.calendarPanels.showNotification) {
                window.calendarPanels.showNotification(errorMessage, 'error');
            }
        }
    } catch (error) {
        console.error('Error creating planned shift:', error);
        
        if (window.calendarPanels && window.calendarPanels.showNotification) {
            window.calendarPanels.showNotification(
                `Ошибка создания смены: ${error.message}`, 
                'error'
            );
        }
    } finally {
        isCreatingShift = false;
    }
}

</script>
