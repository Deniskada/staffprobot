# Логика определения статуса объекта в дашборде владельца

## Блок-схема алгоритма

```
┌─────────────────────────────────────┐
│  Начало: объект с opening_time и    │
│          closing_time               │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Загрузить смены объекта за сегодня: │
│  - Запланированные (planned_start)   │
│  - Спонтанные (start_time/           │
│    actual_start)                     │
└──────────────┬──────────────────────┘
               │
               ▼
      ┌────────┴────────┐
      │  Есть смены?   │
      └───┬────────┬───┘
          │        │
         НЕТ      ДА
          │        │
          ▼        ▼
    ┌─────────┐   │
    │ Нет     │   │
    │ статуса │   │
    └─────────┘   │
                  │
                  ▼
    ┌──────────────────────────────────────┐
    │  РАСЧЁТ ОТКРЫТИЯ ОБЪЕКТА             │
    │                                       │
    │  1. expected_open =                  │
    │     opening_time сегодня              │
    │     (в timezone объекта)             │
    │                                       │
    │  2. Для всех смен:                   │
    │     - Запланированные: actual_start  │
    │     - Спонтанные: start_time         │
    │     → Конвертируем UTC → local       │
    │                                       │
    │  3. Фильтруем смены:                  │
    │     start_local >= expected_open      │
    │                                       │
    │  4. earliest_open_local =            │
    │     минимальный start_local          │
    │     из отфильтрованных                │
    │                                       │
    │  5. delay_minutes =                  │
    │     earliest_open_local -            │
    │     expected_open                    │
    │                                       │
    │  6. threshold_minutes =             │
    │     эффективный порог опоздания      │
    │     (с учётом наследования org_unit) │
    │                                       │
    │  7. Если delay_minutes >             │
    │     threshold_minutes:               │
    │     → late_opening                   │
    │     Иначе:                           │
    │     → timely_opening                 │
    └──────────────┬───────────────────────┘
                   │
                   ▼
    ┌──────────────────────────────────────┐
    │  ПРОВЕРКА УСЛОВИЙ ДЛЯ ЗАКРЫТИЯ       │
    │                                       │
    │  last_shift.end_time существует?    │
    │  AND                                 │
    │  last_shift.status == 'completed'?   │
    │  AND                                 │
    │  active_shifts_on_object == []?     │
    └──────────────┬───────────────────────┘
                   │
                   ▼
            ┌──────┴──────┐
            │  Все условия│
            │  выполнены? │
            └───┬──────┬──┘
                │      │
               НЕТ     ДА
                │      │
                ▼      ▼
         ┌─────────┐   │
         │ Статус  │   │
         │ остаётся│   │
         │ (открытие)│   │
         └─────────┘   │
                       ▼
    ┌──────────────────────────────────────┐
    │  РАСЧЁТ ЗАКРЫТИЯ ОБЪЕКТА            │
    │                                       │
    │  1. expected_close =                 │
    │     closing_time сегодня              │
    │     (в obj.timezone)                 │
    │                                       │
    │  2. actual_close_local =             │
    │     last_shift.end_time              │
    │     (UTC → obj.timezone)             │
    │                                       │
    │  3. early_minutes =                  │
    │     expected_close -                 │
    │     actual_close_local               │
    │                                       │
    │  4. Если early_minutes > 5:          │
    │     → early_closing                  │
    │     Иначе:                           │
    │     → closed                         │
    └──────────────┬───────────────────────┘
                   │
                   ▼
    ┌──────────────────────────────────────┐
    │  ФИНАЛЬНЫЙ СТАТУС                    │
    │                                       │
    │  Если выполняется проверка закрытия: │
    │  → Статус закрытия ПЕРЕЗАПИСЫВАЕТ    │
    │     статус открытия                  │
    │                                       │
    │  work_employee =                     │
    │  - Для открытия: opener_shift.user   │
    │  - Для закрытия: last_shift.user      │
    └──────────────────────────────────────┘
```

## Детальное описание

### Этап 1: Подготовка данных

**Загрузка смен:**
- Запрос к БД включает смены за сегодня, которые:
  - Либо запланированные (`planned_start` в диапазоне дня)
  - Либо спонтанные (`start_time` или `actual_start` в диапазоне дня, но без `planned_start`)

**Если смен нет:**
- Статус работы не рассчитывается
- Остаётся дефолтное значение (или пусто)

### Этап 2: Расчёт статуса открытия

**Шаг 1: Ожидаемое время открытия**
```
expected_open = datetime.combine(today_local, obj.opening_time)
expected_open = timezone_helper.local_tz.localize(expected_open)
```
- Используется `timezone_helper.local_tz` (по умолчанию "Europe/Moscow")

**Шаг 2: Сбор фактических открытий**
- Для каждой смены определяется локальное время начала:
  - **Запланированные:** `actual_start` (UTC → local)
  - **Спонтанные:** `start_time` (UTC → local)

**Шаг 3: Фильтрация кандидатов**
- Игнорируются смены, где `start_local < expected_open`
- Смены, начавшиеся раньше `opening_time`, не считаются открытием объекта

**Шаг 4: Выбор первого открытия**
- Из всех отфильтрованных смен выбирается смена с минимальным `start_local`
- Это и есть `earliest_open_local` и `opener_shift`

**Шаг 5: Расчёт опоздания**
```
delay_minutes = (earliest_open_local - expected_open).total_seconds() / 60
```

**Шаг 6: Получение порога опоздания**
- Функция `get_effective_late_settings_for_object(obj)`:
  1. Проверяет `obj.inherit_late_settings`
  2. Если `False` и `obj.late_threshold_minutes` задано → возвращает его
  3. Иначе поднимается по иерархии `org_unit`:
     - Начинает с `obj.org_unit_id`
     - Пока не найдёт подразделение с `inherit_late_settings = False` и `late_threshold_minutes != None`
     - Возвращает первое найденное
  4. Если ничего не найдено → `threshold_minutes = 0`

**Шаг 7: Определение статуса открытия**
- Если `delay_minutes > threshold_minutes`:
  - `work_status = 'late_opening'`
  - `work_delay = delay_minutes`
  - `work_employee = opener_shift.user`
- Иначе:
  - `work_status = 'timely_opening'`
  - `work_employee = opener_shift.user`

### Этап 3: Расчёт статуса закрытия

**Условия для проверки закрытия:**
1. `last_shift.end_time` существует (смена завершена)
2. `last_shift.status == 'completed'` (статус подтверждён)
3. `active_shifts_on_object == []` (нет активных смен на объекте)

**Если все условия выполнены:**

**Шаг 1: Ожидаемое время закрытия**
```
obj_timezone = obj.timezone or "Europe/Moscow"
naive_expected_close = datetime.combine(today_local, obj.closing_time)
obj_tz = pytz.timezone(obj_timezone)
expected_close = obj_tz.localize(naive_expected_close)
```
- **ВАЖНО:** Используется `obj.timezone`, а не дефолтный `timezone_helper.local_tz`

**Шаг 2: Фактическое время закрытия**
```
actual_close_local = timezone_helper.utc_to_local(
    last_shift.end_time, 
    timezone_str=obj_timezone
)
```
- Конвертация UTC → local в часовом поясе объекта

**Шаг 3: Расчёт раннего закрытия**
```
early_minutes = (expected_close - actual_close_local).total_seconds() / 60
```

**Шаг 4: Определение статуса закрытия**
- Если `early_minutes > 5`:
  - `work_status = 'early_closing'`
  - `work_early = early_minutes`
  - `work_employee = last_shift.user`
- Иначе:
  - `work_status = 'closed'`
  - `work_employee = last_shift.user`

### Этап 4: Приоритет статусов

**ВАЖНО:** Статус закрытия **ПЕРЕЗАПИСЫВАЕТ** статус открытия

- Если выполняется проверка закрытия, то независимо от того, было ли опоздание при открытии, статус будет:
  - Либо `early_closing` (если закрылось раньше ожидаемого на >5 минут)
  - Либо `closed` (если закрылось вовремя или позже)

**Примеры:**

1. Объект открылся с опозданием, но закрылся вовремя:
   - Сначала вычисляется `late_opening`
   - Затем проверяется закрытие → все условия выполнены
   - Статус перезаписывается на `closed`

2. Объект открылся вовремя, но закрылся раньше:
   - Сначала вычисляется `timely_opening`
   - Затем проверяется закрытие → все условия выполнены
   - Статус перезаписывается на `early_closing`

### Этап 5: Отображение сотрудника

- **Для открытия:** `work_employee` = сотрудник из `opener_shift` (первый открывший)
- **Для закрытия:** `work_employee` = сотрудник из `last_shift` (последний закрывший)

## Особенности реализации

### 1. Часовые пояса

**Открытие:**
- Используется `timezone_helper.local_tz` (по умолчанию "Europe/Moscow")
- Это может быть проблемой для объектов в других часовых поясах

**Закрытие:**
- Используется `obj.timezone` (правильно!)
- Это было исправлено в последней итерации

### 2. Фильтрация кандидатов

- Смены, начавшиеся **до** `opening_time`, игнорируются при расчёте открытия
- Это означает, что ранние смены (например, подготовка) не считаются открытием объекта

### 3. Порог раннего закрытия

- **Хардкод:** `if early_minutes > 5`
- Это значение не настраивается через UI
- Можно было бы вынести в настройки объекта

### 4. Наследование настроек опоздания

- Поддержка иерархии `org_unit` для наследования порога опоздания
- Если объект не наследует → использует свои настройки
- Если наследует → поднимается по иерархии до первого подразделения с явными настройками

## Потенциальные проблемы

1. **Несогласованность часовых поясов при открытии:**
   - Для открытия используется `timezone_helper.local_tz`
   - Для закрытия используется `obj.timezone`
   - Это может привести к некорректным расчётам для объектов в других часовых поясах

2. **Хардкод порога раннего закрытия:**
   - Значение `5` минут захардкожено
   - Нет возможности настроить через UI

3. **Фильтрация ранних смен:**
   - Смены, начавшиеся до `opening_time`, игнорируются
   - Это может быть проблемой, если есть ранние смены подготовки, которые должны учитываться








