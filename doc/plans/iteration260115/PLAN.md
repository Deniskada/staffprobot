# Система протоколирования изменений договоров (Iteration 260115)

## Цель
Реализовать систему протоколирования изменений договоров с возможностью ретроспективного просмотра истории изменений и использования исторических данных при расчете начислений.

## Поля для протоколирования
- `hourly_rate` - почасовая ставка
- `use_contract_rate` - признак использования ставки из договора
- `payment_schedule_id` - график выплат
- `inherit_payment_schedule` - признак наследования графика выплат
- `payment_system_id` - система оплаты труда
- `use_contract_payment_system` - признак использования системы оплаты из договора
- `status` - статус договора
- `allowed_objects` - разрешенные объекты
- `title` - название договора
- `template_id` - шаблон договора

## Архитектура

### 1. Модель данных

**Новая таблица: `contract_history`**
- `id` (PK)
- `contract_id` (FK → contracts.id)
- `changed_at` (timestamp) - дата/время изменения
- `changed_by` (FK → users.id) - кто изменил
- `change_type` (enum: 'created', 'updated', 'status_changed') - тип изменения
- `field_name` (string) - название измененного поля
- `old_value` (JSONB) - старое значение
- `new_value` (JSONB) - новое значение
- `change_reason` (text, nullable) - причина изменения (опционально)
- `effective_from` (date, nullable) - дата начала действия (для будущих изменений)
- `metadata` (JSONB, nullable) - дополнительные данные (IP, user agent, etc.)

**Индексы:**
- `(contract_id, changed_at DESC)` - для быстрого получения истории
- `(contract_id, field_name, changed_at DESC)` - для поиска изменений конкретного поля
- `(changed_by, changed_at DESC)` - для аудита действий пользователя

### 2. Сервис протоколирования

**Файл: `shared/services/contract_history_service.py`**

Методы:
- `log_contract_change()` - записать изменение одного поля
- `log_contract_changes()` - записать множественные изменения (batch)
- `get_contract_history()` - получить историю изменений договора
- `get_contract_snapshot()` - получить "снимок" договора на конкретную дату
- `get_field_history()` - получить историю изменений конкретного поля

**Логика определения "снимка" на дату:**
1. Найти все изменения до указанной даты (включительно)
2. Применить изменения в хронологическом порядке
3. Вернуть итоговое состояние договора

### 3. Интеграция в ContractService

**Файл: `apps/web/services/contract_service.py`**

Обновить методы:
- `create_contract()` - записать начальное состояние
- `update_contract()` - записать изменения перед обновлением
- `update_contract_for_manager()` - аналогично
- `update_contract_by_telegram_id()` - аналогично

### 4. API для просмотра истории

**Файл: `apps/web/routes/owner.py`**

Роуты:
- `GET /owner/contracts/{contract_id}/history` - полная история изменений
- `GET /owner/contracts/{contract_id}/history/{field_name}` - история конкретного поля
- `GET /owner/contracts/{contract_id}/snapshot?date=YYYY-MM-DD` - снимок договора на дату
- `GET /api/contracts/{contract_id}/history` - JSON API для истории

### 5. UI для просмотра истории

**Шаблон: `apps/web/templates/owner/contracts/history.html`**

Компоненты:
- Таблица истории изменений с фильтрацией по полям
- Визуализация изменений (старое → новое значение)
- Информация о том, кто и когда изменил
- Возможность просмотра "снимка" на конкретную дату
- Экспорт истории в Excel/PDF

**Интеграция:**
- Добавить вкладку "История" на странице просмотра договора `/owner/employees/contract/{contract_id}`
- Показывать последние изменения в карточке договора

### 6. Обновление логики расчета начислений

**Файл: `core/celery/tasks/payroll_tasks.py`**

При расчете начислений использовать исторические данные договора:
```python
# Для каждой смены определить действующий договор на дату смены
contract_snapshot = await contract_history_service.get_contract_snapshot(
    contract_id=contract.id,
    target_date=shift.start_time.date()
)

# Использовать ставку из снимка
if contract_snapshot.use_contract_rate and contract_snapshot.hourly_rate:
    hourly_rate = contract_snapshot.hourly_rate
else:
    # Логика с тайм-слотом/объектом
    ...
```

**Файл: `apps/bot/services/shift_service.py`**

Аналогично обновить логику определения ставки при открытии смены.

### 7. Миграция данных

**Файл: `migrations/versions/XXXXX_add_contract_history.py`**

Задачи:
1. Создать таблицу `contract_history`
2. Создать индексы
3. Заполнить начальную историю для существующих договоров (снимок текущего состояния)

## Порядок реализации

1. **Фаза 1: Модель и сервис**
   - Создать модель `ContractHistory`
   - Создать миграцию
   - Реализовать `ContractHistoryService`
   - Написать unit-тесты

2. **Фаза 2: Интеграция протоколирования**
   - Интегрировать в `ContractService.create_contract()`
   - Интегрировать в `ContractService.update_contract()`
   - Интегрировать в остальные методы обновления
   - Протестировать протоколирование

3. **Фаза 3: API и UI**
   - Создать API роуты для истории
   - Создать шаблон для просмотра истории
   - Добавить вкладку "История" на странице просмотра договора
   - Добавить экспорт истории

4. **Фаза 4: Обновление логики расчетов**
   - Обновить `payroll_tasks.py` для использования исторических данных
   - Обновить `shift_service.py` для использования исторических данных
   - Протестировать расчеты с историческими данными
   - Миграция данных (заполнение начальной истории)

5. **Фаза 5: Документация и тестирование**
   - Обновить документацию
   - Написать интеграционные тесты
   - Провести регрессионное тестирование

## Важные моменты

1. **Производительность:** Индексы на `(contract_id, changed_at)` критичны для быстрого получения истории
2. **Целостность данных:** При удалении договора история должна сохраняться (soft delete или каскадное удаление по требованию)
3. **Безопасность:** Доступ к истории только для владельца договора и администраторов
4. **Обратная совместимость:** Существующие начисления не пересчитываются автоматически (исторические данные остаются как есть)
5. **Дата начала действия:** Поле `effective_from` позволяет планировать изменения на будущее (опционально)
